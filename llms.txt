# OpenFGA PHP SDK - LLM Knowledge Base

This document contains comprehensive information about the OpenFGA PHP SDK for AI assistants and language models. It includes complete guides, API documentation references, and examples to help implement fine-grained authorization in PHP applications.

**Repository:** https://github.com/evansims/openfga-php  
**Documentation:** https://github.com/evansims/openfga-php/tree/main/docs  
**OpenFGA Documentation:** https://openfga.dev/docs  

## Key Information for AI Assistants

- **Language:** PHP 8.3+
- **Package Name:** `evansims/openfga-php`
- **Installation:** `composer require evansims/openfga-php`
- **Purpose:** Fine-grained authorization and relationship-based access control
- **Architecture:** Result pattern for error handling, PSR-7/17/18 HTTP standards
- **Testing:** `composer test` (unit, integration, contract tests)
- **Documentation Generation:** `composer docs:api`

## Complete Guides and Documentation


### SDK Overview and Quick Start

<div align="center">
  <p><a href="https://tempestphp.com"><img src="https://raw.githubusercontent.com/evansims/openfga-php/main/.github/openfga.png" width="100" /></a></p>

  <h1>OpenFGA PHP SDK</h1>

  <p>Stop writing authorization logic. Start asking questions.</p>

  <p><code>composer require evansims/openfga-php</code></p>
</div>

<p><br /></p>

##### Getting Started

Build your authorization integration

- [Introduction](Introduction.md)<br />
  Start here to get your first authorization check working.
- [Installation](Introduction.md#install-the-sdk)<br />
  Install the SDK and set up your first authorization store.
- [Authentication](Authentication.md)<br />
  Set up authentication for production environments and managed services.

##### Essentials

Learn the core concepts and patterns

- [Stores](Stores.md)<br />
  Manage authorization stores for multi-tenant applications and environment separation.
- [Authorization Models](Models.md)<br />
  Learn how to define your permission rules using OpenFGA's intuitive DSL.
- [Relationship Tuples](Tuples.md)<br />
  Understand how to grant and revoke specific permissions between users and resources.
- [Permission Queries](Queries.md)<br />
  Master the four types of queries: check permissions, list objects, find users, and expand relationships.
- [Assertions](Assertions.md)<br />
  Define test cases to verify your authorization model.

##### Features

Explore advanced features and patterns

- [Concurrency](Concurrency.md)<br />
  Leveraging the SDK's powerful concurrency features to improve performance when working with large-scale authorization operations.
- [Exceptions](Exceptions.md)<br />
  Handling errors and exceptions in your authorization system.
- [Integration](Integration.md)<br />
  Integrating OpenFGA with your existing systems and frameworks.
- [Observability](Observability.md)<br />
  Comprehensive tracing and metrics to monitor your authorization system.
- [Results](Results.md)<br />
  Building robust applications with proper response handling using the SDK's Result pattern.


### Getting Started Guide

#### Getting started

Build your first authorization system in under 10 minutes. You'll install the SDK, connect to OpenFGA, and check your first permission.

##### What you'll learn

By the end of this guide, you'll have a working authorization system that can answer questions like "Can Alice view this document?" and understand the core concepts that power modern permission systems.

##### Prerequisites

**Required:**

- PHP 8.3+ and Composer
- An OpenFGA server (local or remote)

**HTTP Libraries (auto-detected):**
The SDK will automatically discover and use existing PSR-7/17/18 libraries in your project. If you don't have any yet:

```bash
composer require guzzlehttp/guzzle guzzlehttp/psr7
```

**Common imports for examples:**
Most examples in this guide use these imports:

```php
<?php

use OpenFGA\Client;
use function OpenFGA\{store, dsl, model, tuple, tuples, write, allowed};
```

##### Start an OpenFGA server

The easiest way is Docker - one command gets you running:

```bash
docker run -d -p 8080:8080 --name openfga openfga/openfga run
```

Your server is now accessible at `http://localhost:8080`.

**Using a managed service?** Skip this step and use your Auth0 FGA or hosted OpenFGA URL instead.

##### Install the SDK

```bash
composer require evansims/openfga-php
```

##### Create your first client

```php
$client = new Client(url: 'http://localhost:8080');
```

That's it. The client automatically discovers your HTTP libraries and handles all the low-level communication.

**For production:** You'll want authentication and better error handling. We'll cover that in [Authentication →](Authentication.md) and [Results →](Results.md).

##### How authorization works

Every authorization system needs three things:

**1. A store** — Think of this as a database for your permissions. Each application or tenant gets its own store.

**2. A model** — The rules that define what permissions exist. Like "documents can have viewers and editors."

**3. Relationships** — Specific permissions between users and resources. Like "Alice can view document:readme."

Once you have these, you can ask questions like "Can Alice edit this document?" and get instant answers.

##### Build your first authorization system

Here's a complete working example that sets up authorization for a document system:

```php
$client = new Client(url: 'http://localhost:8080');

// 1. Create a store for your app
$storeId = store($client, 'document-system');
echo "Created store: {$storeId}\n";

// 2. Define what permissions exist
$dsl = <<<DSL
model
  schema 1.1

type user

type document
  relations
    define viewer: [user]
    define editor: [user]
DSL;

$model = dsl($client, $dsl);
$modelId = model($client, $storeId, $model);
echo "Created model: {$modelId}\n";

// 3. Grant Alice permission to view the readme
write(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('user:alice', 'viewer', 'document:readme')
);
echo "Granted alice viewer permission on readme\n";

// 4. Check if Alice can view the document
$canView = allowed(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuple: tuple('user:alice', 'viewer', 'document:readme')
);

echo $canView ? "✅ Alice can view readme" : "❌ Access denied";
```

**Run this example:**

1. Make sure your OpenFGA server is running
2. Save the code as `example.php`
3. Run `php example.php`

You should see confirmation messages and a final "Alice can view readme" success message.

##### What's next?

Now that you have a working authorization system, here's your path forward:

###### Next Steps for New Developers

**If you're just getting started:**

1. **[Authorization Models →](Models.md)** - Build more complex permission rules
2. **[Relationship Tuples →](Tuples.md)** - Learn to manage permissions at scale
3. **[Queries →](Queries.md)** - Master all four types of permission checks

**If you're ready for production:**

1. **[Authentication →](Authentication.md)** - Secure your OpenFGA connection
2. **[Results →](Results.md)** - Handle errors gracefully with the Result pattern
3. **[Stores →](Stores.md)** - Manage multiple environments and tenants

###### Advanced Topics

**Performance & Scale:**

- **[Concurrency →](Concurrency.md)** - Optimize batch operations with PHP fibers
- **[Observability →](Observability.md)** - Monitor and debug with OpenTelemetry

**Quality Assurance:**

- **[Assertions →](Assertions.md)** - Test your authorization models
- **[Exceptions →](Exceptions.md)** - Master error handling patterns


### Authentication and Configuration

#### Authentication

Most OpenFGA servers require authentication, especially in production. This guide shows you how to configure authentication for different environments and use cases.

##### Prerequisites

The examples in this guide assume you have the following imports available:

```php
use OpenFGA\Client;
use OpenFGA\ClientInterface;
use OpenFGA\Authentication\{ClientCredentialAuthentication, TokenAuthentication};
```

##### TL;DR for busy developers

```php
// Production with client credentials (most common)
$client = new Client(
    url: $_ENV['FGA_API_URL'],
    authentication: new ClientCredentialAuthentication(
        clientId: $_ENV['FGA_CLIENT_ID'],
        clientSecret: $_ENV['FGA_CLIENT_SECRET'],
        issuer: $_ENV['FGA_ISSUER'],
        audience: $_ENV['FGA_AUDIENCE'],
    ),
);

// Local development (no auth)
$client = new Client(url: 'http://localhost:8080');
```

##### When do you need authentication?

- **Production environments** - Always required
- **Auth0 FGA** - Always required
- **Local development** - Usually optional

##### Production Setup

###### Client Credentials (Recommended)

This is the most common authentication method for production applications. The SDK handles OAuth token management automatically.

```php
$client = new Client(
    url: $_ENV['FGA_API_URL'],
    authentication: new ClientCredentialAuthentication(
        clientId: $_ENV['FGA_CLIENT_ID'],
        clientSecret: $_ENV['FGA_CLIENT_SECRET'],
        issuer: $_ENV['FGA_ISSUER'],
        audience: $_ENV['FGA_AUDIENCE'],
    ),
);
```

**Environment variables:**

```bash
FGA_API_URL=https://api.us1.fga.dev
FGA_CLIENT_ID=your_client_id
FGA_CLIENT_SECRET=your_client_secret
FGA_ISSUER=https://your-tenant.us.auth0.com/oauth/token
FGA_AUDIENCE=https://api.us1.fga.dev/
```

###### API Token

For simpler setups or self-hosted OpenFGA instances that support API tokens:

```php
$client = new Client(
    url: $_ENV['FGA_API_URL'],
    authentication: new TokenAuthentication($_ENV['FGA_API_TOKEN']),
);
```

**Environment variables:**

```bash
FGA_API_URL=https://your-openfga-server.com
FGA_API_TOKEN=your_api_token
```

##### Development Setup

For local development against a Docker container or development server:

```php
$client = new Client(
    url: $_ENV['FGA_API_URL'] ?? 'http://localhost:8080',
);
```

##### Client Configuration Patterns

###### Using a factory method

```php
final readonly class FgaClientFactory
{
    public static function create(): Client
    {
        return match ($_ENV['APP_ENV'] ?? 'production') {
            'development', 'testing' => new Client(
                url: $_ENV['FGA_API_URL'] ?? 'http://localhost:8080',
            ),
            default => new Client(
                url: $_ENV['FGA_API_URL'],
                authentication: new ClientCredentialAuthentication(
                    clientId: $_ENV['FGA_CLIENT_ID'],
                    clientSecret: $_ENV['FGA_CLIENT_SECRET'],
                    issuer: $_ENV['FGA_ISSUER'],
                    audience: $_ENV['FGA_AUDIENCE'],
                ),
            ),
        };
    }
}
```

###### Dependency injection

```php
// In your service container
$container->singleton(ClientInterface::class, function () {
    return new Client(
        url: config('fga.url'),
        authentication: new ClientCredentialAuthentication(
            clientId: config('fga.client_id'),
            clientSecret: config('fga.client_secret'),
            issuer: config('fga.issuer'),
            audience: config('fga.audience'),
        ),
    );
});
```

##### Troubleshooting

###### Authentication failed

- Verify your environment variables are set correctly
- Check that your client ID and secret are valid
- Ensure the issuer URL includes the full path (for example `/oauth/token`)

###### Token expired errors

The SDK automatically refreshes tokens for Client Credentials authentication. If you're seeing expired token errors:

- Check your system clock is accurate
- Verify the audience URL matches your OpenFGA API endpoint exactly

###### Local development issues

If authentication isn't working locally:

- Confirm your OpenFGA server allows unauthenticated requests
- Check the server logs for authentication requirements

###### Environment variable loading

Use a package like `vlucas/phpdotenv` for development:

```php
// Load .env file in development
if (file_exists(__DIR__ . '/.env')) {
    $dotenv = Dotenv\Dotenv::createImmutable(__DIR__);
    $dotenv->load();
}
```


### Store Management

#### Stores

Think of a store as your authorization workspace. It contains your permission rules, user relationships, and everything needed to answer "can this user do that?" Each store is completely isolated - perfect for separating environments, tenants, or applications.

Every OpenFGA operation happens within a store, making them the foundation of your authorization system.

##### Prerequisites

The examples in this guide assume you have the following setup:

```php
use OpenFGA\Client;
use function OpenFGA\store;

// Initialize your client
$client = new Client(url: $_ENV['FGA_API_URL']);
```

##### What are stores?

A store holds three things:

- **Authorization models** - your permission rules
- **Relationship tuples** - who can do what
- **Assertions** - tests to verify everything works

Most apps start with one store and add more as they grow.

##### Single application setup

For a typical application, create one store per environment:

```php
// Create your production store
$storeId = store($client, 'myapp-production'); // Save this!

// Configure your client to use this store
$client = $client->withStore(store: $storeId);
```

Store that ID in your environment configuration - you'll need it for every API call.

##### Multi-tenant patterns

For SaaS applications, create a store per customer to ensure complete data isolation:

```php
final readonly class TenantStoreManager
{
    public function __construct(private Client $client) {}

    public function createTenantStore(string $customerId): string
    {
        $store = $this->client
            ->createStore(name: "customer-{$customerId}")
            ->unwrap();

        return $store->getId();
    }

    public function getClientForTenant(string $customerId): Client
    {
        $storeId = $this->lookupStoreId($customerId);
        return $this->client->withStore(store: $storeId);
    }
}

// Usage
$manager = new TenantStoreManager($client);
$storeId = $manager->createTenantStore('acme-corp');
```

##### Environment separation

Keep your environments completely isolated:

```php
enum Environment: string
{
    case Development = 'dev';
    case Staging = 'staging';
    case Production = 'prod';
}

function createEnvironmentStore(Client $client, Environment $env, string $appName): string
{
    $store = $client->createStore(name: "{$appName}-{$env->value}")->unwrap();
    return $store->getId();
}

// Create stores for each environment
$devStoreId = createEnvironmentStore($client, Environment::Development, 'myapp');
$prodStoreId = createEnvironmentStore($client, Environment::Production, 'myapp');
```

##### Store management

Finding and managing existing stores:

```php
// List all stores
$stores = $client->listStores(pageSize: 20)->unwrap();
foreach ($stores->getStores() as $store) {
    echo "{$store->getName()}: {$store->getId()}\n";
}

// Get specific store details (using store ID from previous examples)
$store = $client->getStore(store: $storeId)->unwrap();
echo "Created: {$store->getCreatedAt()->format('Y-m-d H:i:s')}\n";

// Delete a store (careful - this is permanent!)
$client->deleteStore(store: $storeId)->unwrap();
```

For pagination with many stores:

```php
$continuationToken = null;
do {
    $response = $client->listStores(
        pageSize: 10,
        continuationToken: $continuationToken
    )->unwrap();

    foreach ($response->getStores() as $store) {
        // Process each store
    }

    $continuationToken = $response->getContinuationToken();
} while ($continuationToken !== null);
```

##### Best practices

**When to use multiple stores:**

- Different environments (dev/staging/production)
- Different customers in SaaS apps
- Different applications with no shared permissions
- Compliance requirements for data isolation

**When to use a single store:**

- Different user roles (use authorization models instead)
- Different features in the same app (use object types)
- A/B testing (use different object IDs)

**Naming conventions:**

```php
// Good names
'myapp-production'
'customer-acme-corp'
'billing-service-staging'

// Avoid
'store1'
'test'
'temp'
```

**Pro tips:**

- Start with one store per environment
- Save store IDs in your configuration
- Test your app works with store switching
- Document which team owns each store

##### Next steps

With your store ready, create an [Authorization Model](Models.md) to define your permission rules.


### Authorization Models and DSL

#### Authorization Models

Authorization models are your permission blueprint. They define what types of things exist in your system and how they relate to each other. Think database schema, but for permissions.

##### Prerequisites

The examples in this guide assume you have the following setup:

```php
use OpenFGA\Client;
use OpenFGA\Models\{Condition, ConditionMetadata, ConditionParameter};
use OpenFGA\Models\Collections\{Conditions, ConditionParameters};

$client = new Client(url: 'http://localhost:8080');
$storeId = 'your-store-id'; // From creating a store or your configuration
$modelId = 'your-model-id'; // From creating an authorization model
```

##### Building your first model

Let's jump right into building a document sharing system. Here's what we want:

- Users can own, edit, or view documents
- Owners can do everything
- Editors can edit and view
- Viewers can only view

```fsharp
model
  schema 1.1

type user

type document
  relations
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor
```

That's it. The `or` keyword creates inheritance - owners automatically become editors, and editors automatically become viewers.

##### Creating your model

Transform your DSL into a model object and create it on the server:

```php
$dsl = <<<DSL
model
  schema 1.1

type user

type document
  relations
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor
DSL;

// Transform DSL to model object
$model = $client->dsl($dsl)->unwrap();

// Create on server
$response = $client->createAuthorizationModel(
    store: $storeId,
    typeDefinitions: $model->getTypeDefinitions(),
    conditions: $model->getConditions()
)->unwrap();

$modelId = $response->getId();
```

Save that `$modelId` - you'll need it for everything else.

##### Common patterns

###### Direct assignment

The simplest relationship - a user directly has a role:

```fsharp
type document
  relations
    define owner: [user]
```

This lets you write tuples like `user:alice owner document:readme`.

###### Computed relations

Relations that inherit from other relations:

```fsharp
type document
  relations
    define owner: [user]
    define editor: owner  // All owners are editors
    define viewer: editor // All editors are viewers
```

###### Union relations

Multiple ways to get the same permission:

```fsharp
type document
  relations
    define owner: [user]
    define editor: [user] or owner     // Direct editors OR owners
    define viewer: [user] or editor    // Direct viewers OR editors
```

###### Hierarchical permissions

Inherit permissions from parent objects:

```fsharp
type folder
  relations
    define owner: [user]
    define viewer: [user] or owner

type document
  relations
    define parent: [folder]
    define owner: [user]
    define viewer: [user] or owner or viewer from parent
```

Now documents inherit viewer permissions from their parent folder.

###### Group membership

Users belong to groups, groups have permissions:

```fsharp
type user

type group
  relations
    define member: [user]

type document
  relations
    define owner: [user, group#member]
    define viewer: [user, group#member] or owner
```

The `group#member` syntax means "users who are members of the group".

##### Working with conditions

Add context-aware permissions using conditions:

```fsharp
type document
  relations
    define viewer: [user with valid_ip]
    define editor: [user with business_hours]
```

Define conditions when creating your model:

```php
$conditions = new Conditions([
    new Condition(
        name: 'valid_ip',
        expression: 'ip_address in allowed_ips',
        parameters: new ConditionParameters([
            new ConditionParameter(
                name: 'allowed_ips',
                typeName: 'list'
            )
        ])
    )
]);

$response = $client->createAuthorizationModel(
    store: $storeId,
    typeDefinitions: $model->getTypeDefinitions(),
    conditions: $conditions
)->unwrap();
```

##### Using models in your application

###### Set the active model

```php
$client->setModel($modelId);
```

###### Check permissions

```php
$canView = $client->check(
    user: 'user:alice',
    relation: 'viewer',
    object: 'document:readme'
)->unwrap()->getAllowed();
```

###### List user's objects

```php
$documents = $client->listObjects(
    user: 'user:alice',
    relation: 'viewer',
    type: 'document'
)->unwrap()->getObjects();
```

##### Advanced patterns

###### Multi-tenant systems

Each tenant has their own workspace:

```fsharp
type user

type tenant
  relations
    define member: [user]
    define admin: [user]

type document
  relations
    define tenant: [tenant]
    define owner: [user] and member from tenant
    define viewer: [user] and member from tenant
```

The `and` keyword requires both conditions - users must be both assigned the role AND be members of the tenant.

###### Approval workflows

Documents need approval before publishing:

```fsharp
type document
  relations
    define owner: [user]
    define editor: [user] or owner
    define approver: [user]
    define can_publish: approver and owner
    define viewer: [user] or can_publish
```

###### Time-based access

```fsharp
type document
  relations
    define owner: [user]
    define viewer: [user with during_work_hours] or owner
```

###### Nested resources

Permissions flow down through resource hierarchies:

```fsharp
type organization
  relations
    define admin: [user]
    define member: [user] or admin

type project
  relations
    define organization: [organization]
    define admin: [user] or admin from organization
    define member: [user] or member from organization

type document
  relations
    define project: [project]
    define editor: [user] or admin from project
    define viewer: [user] or member from project
```

##### Managing models

###### List all models

```php
$models = $client->listAuthorizationModels(
    store: $storeId,
    pageSize: 10
)->unwrap()->getModels();

foreach ($models as $model) {
    echo "Model ID: " . $model->getId() . "\n";
}
```

###### Get a specific model

```php
$model = $client->getAuthorizationModel(
    store: $storeId,
    model: $modelId
)->unwrap()->getModel();

// Convert back to DSL
echo $model->dsl();
```

###### Version your models

Always create new models instead of modifying existing ones. Keep the old model ID for backward compatibility:

```php
// Deploy new model
$newModelId = $client->createAuthorizationModel(/*...*/)
    ->unwrap()->getId();

// Gradually migrate tuples to new model
// Switch applications to use $newModelId
```

##### Troubleshooting Common Issues

###### "My permissions aren't working as expected"

- Use the [expand query](Queries.md#expand-relationships-debugging) to see the permission tree
- Check if you're using the correct model ID in your checks
- Verify your authorization model DSL syntax

###### "Users have too many permissions"

- Check for unintended `or` relationships in your model
- Review inheritance patterns - owners might inherit editor/viewer permissions
- Use [assertions](Assertions.md) to test expected vs actual permissions

###### "Users don't have enough permissions"

- Verify relationships are written correctly as tuples
- Check if you're querying with the right object/relation names
- Use [read tuples](Tuples.md#reading-existing-permissions) to see what permissions exist

##### What's next

Now that you have a model:

1. **[Write relationship tuples](Tuples.md)** - Connect users to objects with actual permissions
2. **[Perform queries](Queries.md)** - Check permissions and list accessible objects
3. **[Test with assertions](Assertions.md)** - Verify your model works as designed

Your authorization model is the foundation everything else builds on. Take time to design it well - changing it later requires migrating all your tuples.


### Relationship Tuples

#### Relationship Tuples

Relationship tuples are where the rubber meets the road. They're the actual permissions in your system - who can do what to which resource.

A tuple is simply: `(user, relation, object)`

For example: `(user:anne, editor, document:roadmap)` means "Anne can edit the roadmap document."

##### Prerequisites

The examples in this guide assume you have the following setup:

```php
<?php

use OpenFGA\Client;
use OpenFGA\Exceptions\{ClientError, ClientException};
use OpenFGA\Models\{ConditionParameter, ConditionParameters, RelationshipCondition, TupleKey, TupleKeys};
use function OpenFGA\{tuple, tuples, write, delete, result};

// Client initialization - see Getting Started for full details
$client = new Client(url: 'http://localhost:8080');

// Store and model identifiers from your configuration
$storeId = 'your-store-id';
$modelId = 'your-model-id';
```

##### Granting Permissions

Give someone access by writing a tuple:

```php
// Give Anne editor access to a document
write(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('user:anne', 'editor', 'document:roadmap')
);
```

##### Removing Permissions

Take away access by deleting a tuple:

```php
// Remove Anne's editor access
delete(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('user:anne', 'editor', 'document:roadmap')
);
```

##### Bulk Operations

Handle multiple permission changes in one transaction:

```php
// Grant access to multiple users and revoke old permissions
$client->writeTuples(
    store: $storeId,
    model: $modelId,
    writes: tuples(
        tuple('user:bob', 'viewer', 'document:roadmap'),
        tuple('user:charlie', 'editor', 'document:roadmap'),
        tuple('team:marketing#member', 'viewer', 'folder:campaigns')
    ),
    deletes: tuples(
        tuple('user:anne', 'owner', 'document:old-spec')
    )
)->unwrap();
```

##### Reading Existing Permissions

Check what permissions exist by reading tuples:

```php
// Find all permissions for a specific document
$response = $client->readTuples(
    store: $storeId,
    model: $modelId,
    tupleKey: new TupleKey(object: 'document:roadmap')
)->unwrap();

foreach ($response->getTuples() as $tuple) {
    echo "{$tuple->getUser()} has {$tuple->getRelation()} on {$tuple->getObject()}\n";
}
```

```php
// Find all documents Anne can edit
$response = $client->readTuples(
    store: $storeId,
    model: $modelId,
    tupleKey: new TupleKey(user: 'user:anne', relation: 'editor')
)->unwrap();

foreach ($response->getTuples() as $tuple) {
    echo "Anne can edit: {$tuple->getObject()}\n";
}
```

```php
// Paginate through all tuples
$continuationToken = null;

do {
    $response = $client->readTuples(
        store: $storeId,
        model: $modelId,
        pageSize: 100,
        continuationToken: $continuationToken
    )->unwrap();

    foreach ($response->getTuples() as $tuple) {
        // Process each tuple...
    }

    $continuationToken = $response->getContinuationToken();
} while ($continuationToken !== null);
```

##### Advanced Patterns

###### Conditional Tuples

Add conditions to make permissions context-dependent:

```php
// Only allow access during business hours
$client->writeTuples(
    store: $storeId,
    model: $modelId,
    writes: new TupleKeys([
        new TupleKey(
            user: 'user:contractor',
            relation: 'viewer',
            object: 'document:sensitive',
            condition: new RelationshipCondition(
                name: 'business_hours',
                context: [
                    'timezone' => 'America/New_York'
                ]
            )
        )
    ])
)->unwrap();
```

###### Tracking Changes

Monitor permission changes over time for auditing:

```php
// Get all permission changes for documents in the last hour
$startTime = (new DateTimeImmutable())->sub(new DateInterval('PT1H'));

$response = $client->listTupleChanges(
    store: $storeId,
    model: $modelId,
    type: 'document',
    startTime: $startTime
)->unwrap();

foreach ($response->getChanges() as $change) {
    $tuple = $change->getTupleKey();
    echo "{$change->getOperation()->value}: {$tuple->getUser()} {$tuple->getRelation()} {$tuple->getObject()}\n";
}
```

###### Working with Groups

Grant permissions to groups instead of individual users:

```php
// Add user to a group
write(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('user:anne', 'member', 'team:engineering')
);

// Grant permission to the entire group
write(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('team:engineering#member', 'editor', 'document:technical-specs')
);
```

Now Anne can edit the technical specs because she's a member of the engineering team.

For checking permissions and querying relationships, see [Queries](Queries.md).

##### Error Handling with Tuples

When working with tuples, it's important to handle errors properly using the SDK's enum-based exception handling:

```php
// Example: Writing tuples with robust error handling
function addUserToDocument(string $userId, string $documentId, string $role = 'viewer'): bool
{
    global $client, $storeId, $modelId;
    
    // Use result helper for cleaner error handling
    return result(function() use ($client, $storeId, $modelId, $userId, $documentId, $role) {
        return write(
            client: $client,
            store: $storeId,
            model: $modelId,
            tuples: tuple("user:{$userId}", $role, "document:{$documentId}")
        );
    })
    ->success(function() {
        logger()->info('Access granted', [
            'user' => $userId,
            'document' => $documentId,
            'role' => $role
        ]);
        return true;
    })
    ->failure(function(Throwable $error) use ($userId, $documentId, $role) {
        // Enum-based error handling with match expression
        if ($error instanceof ClientException) {
            match($error->getError()) {
                // Handle validation errors specifically
                ClientError::Validation => logger()->warning(
                    'Validation error granting access',
                    ['context' => $error->getContext()]
                ),

                // Handle authorization model mismatches
                ClientError::InvalidConfiguration => logger()->error(
                    'Model configuration error',
                    ['message' => $error->getMessage()]
                ),

                // Default case for other client errors
                default => logger()->error(
                    'Failed to grant access',
                    ['error_type' => $error->getError()->name]
                )
            };
        } else {
            // Handle unexpected errors
            logger()->error('Unexpected error granting access', [
                'error' => $error->getMessage(),
                'user' => $userId,
                'document' => $documentId
            ]);
        }

        return false;
    })
    ->unwrap();
}
```

###### Supporting Multiple Languages

The error messages from tuple operations will automatically use the language configured in your client:

```php
// Create a client with Spanish error messages
$client = new Client(
    url: 'https://api.openfga.example',
    language: 'es' // Spanish
);

try {
    // Attempt to write an invalid tuple
    write(
        client: $client,
        store: $storeId,
        model: $modelId,
        tuples: tuple('', 'viewer', 'document:report')
    );
} catch (ClientException $e) {
    // The error message will be in Spanish
    echo $e->getMessage(); // "El identificador del usuario no puede estar vacío"

    // But the error enum remains the same for consistent handling
    if ($e->getError() === ClientError::Validation) {
        // Handle validation error regardless of language
    }
}
```


### Authorization Queries and Checks

#### Queries

Ready to check permissions? Once you've set up your [authorization model](Models.md) and [relationship tuples](Tuples.md), it's time to actually use them. This is where OpenFGA shines - answering permission questions in real-time.

##### Prerequisites

Before diving into the examples, make sure you have the necessary setup:

```php
use OpenFGA\{Client, ClientInterface};
use OpenFGA\Models\{TupleKey, Enums\Consistency};
use OpenFGA\Exceptions\{ClientError, ClientException, NetworkError, NetworkException};
use function OpenFGA\{allowed, tuple, tuples, result, success, failure, unwrap};

// Your configured client
$client = new Client(url: 'http://localhost:8080');

// Your store and model identifiers
$storeId = 'your-store-id';
$modelId = 'your-model-id';
```

##### What are queries?

Queries let you ask OpenFGA about permissions. There are four types:

- **Check permissions** - "Can Alice edit this document?"
- **List accessible objects** - "What documents can Alice edit?"
- **Find users with permission** - "Who can edit this document?"
- **Expand relationships** - "How does Alice have edit access?" (for debugging)

##### Check permissions

This is the most common query. Use it to enforce access control in your app.

```php
// Can user:alice view document:roadmap?
$result = $client->check(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'viewer',
        object: 'document:roadmap'
    )
);

if ($result->unwrap()->getAllowed()) {
    // Alice can view the document
    echo "Access granted";
} else {
    // Alice cannot view the document
    echo "Access denied";
}
```

###### Real-world usage

```php
function canUserEdit(ClientInterface $client, string $storeId, string $modelId, string $userId, string $documentId): bool
{
    return allowed(
        client: $client,
        store: $storeId,
        model: $modelId,
        tuple: tuple("user:{$userId}", 'editor', "document:{$documentId}")
    );
}

// In your controller or middleware
if (!canUserEdit($client, $storeId, $modelId, $currentUserId, $documentId)) {
    throw new ForbiddenException('You cannot edit this document');
}

// For multiple checks, use the Result pattern for better error handling
$editResult = $client->check(
    tupleKey: tuple("user:{$userId}", 'editor', "document:{$documentId}")
);

if ($editResult->failed()) {
    logger()->warning('Permission check failed', ['error' => $editResult->err()->getMessage()]);
    // Handle error - maybe return false or show a generic error
}
```

##### List accessible objects

Perfect for building dashboards and filtered lists. Shows what a user can access.

```php
// What documents can alice edit?
$result = $client->listObjects(
    user: 'user:alice',
    relation: 'editor',
    type: 'document'
);

$documentIds = $result->unwrap()->getObjects();
// Returns: ['roadmap', 'budget', 'proposal']
```

###### Building a document list

```php
function getEditableDocuments(string $userId): array
{
    $result = $client->listObjects(
        user: "user:{$userId}",
        relation: 'editor',
        type: 'document'
    );

    $documentIds = $result->unwrap()->getObjects();

    // Fetch full document details from your database
    return Document::whereIn('id', $documentIds)->get();
}
```

##### Find users with permission

Great for admin interfaces and sharing features. Shows who has access to something.

```php
// Who can edit document:roadmap?
$result = $client->listUsers(
    object: 'document:roadmap',
    relation: 'editor'
);

$users = $result->unwrap()->getUsers();

foreach ($users as $user) {
    if ($user->isUser()) {
        echo "User: " . $user->getUserId() . "\n";
    } elseif ($user->isUserset()) {
        echo "Group: " . $user->getUsersetObject() . "\n";
    }
}
```

###### Building a sharing interface

```php
function getDocumentEditors(string $documentId): array
{
    $result = $client->listUsers(
        object: "document:{$documentId}",
        relation: 'editor'
    );

    $editors = [];
    foreach ($result->unwrap()->getUsers() as $user) {
        if ($user->isUser()) {
            $editors[] = [
                'type' => 'user',
                'id' => $user->getUserId(),
                'name' => User::find($user->getUserId())->name
            ];
        }
    }

    return $editors;
}
```

##### Expand relationships (debugging)

When permissions aren't working as expected, use expand to see why. It shows the complete relationship tree.

```php
// How can anyone be a viewer of document:roadmap?
$result = $client->expand(
    tupleKey: new TupleKey(
        relation: 'viewer',
        object: 'document:roadmap'
        // Note: no user specified for expand
    )
);

$tree = $result->unwrap()->getTree();
print_r($tree->toArray()); // Shows the complete permission tree
```

This is mainly useful for debugging complex permission structures or understanding why a user has (or doesn't have) access.

##### Advanced patterns

###### Contextual tuples

Test "what-if" scenarios without permanently saving relationships. Perfect for previewing permission changes.

```php
// What if alice joins the engineering team?
$contextualTuple = tuple(
    user: 'user:alice',
    relation: 'member',
    object: 'team:engineering'
);

$result = $client->check(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'viewer',
        object: 'document:technical-specs'
    ),
    contextualTuples: tuples($contextualTuple)
);

// This check includes the temporary relationship
$wouldHaveAccess = $result->unwrap()->getIsAllowed();
```

###### Consistency levels

For read-after-write scenarios, you might need stronger consistency:

```php
$result = $client->check(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'viewer',
        object: 'document:roadmap'
    ),
    consistency: Consistency::HIGHER_CONSISTENCY
);
```

###### Error handling

All query methods return Result objects. Handle errors gracefully using the Result pattern and helper functions:

```php
// Basic error handling
$result = $client->check(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'viewer',
        object: 'document:roadmap'
    )
);

$result
    ->success(fn($response) => echo "Check succeeded: " . ($response->getAllowed() ? 'Allowed' : 'Denied'))
    ->failure(fn($error) => logger()->error("Permission check failed", [
        'error_type' => $error::class,
        'error_detail' => $error instanceof ClientException ? $error->getError()->name : 'unknown'
    ]))
    ->unwrap(); // Throws on failure
```

###### Advanced error handling with enum-based exceptions

Use enum-based exceptions for more precise error handling with i18n support:

```php
// Define a robust permission checking service
// Note: This is an example helper class and not part of the SDK.
// It also assumes the existence of a CacheInterface for caching.
class PermissionService
{
    public function __construct(
        private ClientInterface $client,
        private string $storeId,
        private string $modelId,
        private CacheInterface $cache
    ) {}

    public function canAccess(string $userId, string $action, string $resourceId): bool
    {
        // Use result helper for cleaner handling
        return result(function() use ($userId, $action, $resourceId) {
            return $this->client->check(
                store: $this->storeId,
                model: $this->modelId,
                tupleKey: tuple("user:{$userId}", $action, $resourceId)
            );
        })
        ->then(fn($response) => $response->getAllowed())
        ->failure(function(Throwable $error) use ($userId, $action, $resourceId) {
            // Handle different error types with match expression
            if ($error instanceof ClientException) {
                // Type-safe handling of specific error cases
                return match($error->getError()) {
                    // For network timeouts, use cached result with short TTL
                    ClientError::Network => $this->getCachedPermission(
                        $userId,
                        $action,
                        $resourceId,
                        $defaultValue = false // Fail closed by default
                    ),

                    // For validation errors, log detailed context
                    ClientError::Validation => $this->handleValidationError(
                        $error->getContext(),
                        $userId,
                        $action,
                        $resourceId
                    ),

                    // For other cases, gracefully fail closed
                    default => false
                };
            }

            // For unexpected errors, log and fail closed
            logger()->error('Unexpected error during permission check', [
                'user' => $userId,
                'action' => $action,
                'resource' => $resourceId,
                'error' => $error->getMessage()
            ]);

            return false; // Secure default
        })
        ->unwrap();
    }

    private function getCachedPermission(string $userId, string $action, string $resourceId, bool $default): bool
    {
        $cacheKey = "permission:{$userId}:{$action}:{$resourceId}";
        return $this->cache->get($cacheKey, $default);
    }

    private function handleValidationError(array $context, string $userId, string $action, string $resourceId): bool
    {
        logger()->warning('Validation error during permission check', [
            'context' => $context,
            'user' => $userId,
            'action' => $action,
            'resource' => $resourceId
        ]);

        // Analyze context to determine appropriate fallback behavior
        // For this example, we'll fail closed
        return false;
    }
}
```

##### Common Query Patterns

###### Permission gates for routes

```php
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

// Middleware for route protection
class FgaAuthMiddleware
{
    public function __construct(
        private readonly ClientInterface $client,
        private readonly string $store,
        private readonly string $model
    ) {
    }

    public function handle(Request $request, Closure $next, string $relation): Response
    {
        $user = $request->user();
        $resource = $request->route('document'); // or extract from URL

        if (!allowed($this->client, $this->store, $this->model,
                     tuple("user:{$user->id}", $relation, "document:{$resource}"))) {
            abort(403, "You don't have {$relation} access to this resource");
        }

        return $next($request);
    }
}
```

###### Efficient data filtering

```php
// Instead of checking each item individually
function getEditableDocuments(string $userId): Collection
{
    // ❌ Don't do this - N+1 problem
    // return Document::all()->filter(fn($doc) =>
    //     allowed($client, $store, $model, tuple($userId, 'editor', $doc->id))
    // );

    // ✅ Do this - single API call
    $editableIds = $client->listObjects(
        user: "user:{$userId}",
        relation: 'editor',
        type: 'document'
    )->unwrap()->getObjects();

    return Document::whereIn('id', $editableIds)->get();
}
```

###### Debugging permission issues

```php
// When "why doesn't this user have access?" questions arise
function debugUserAccess(string $userId, string $documentId): void
{
    // Check direct permission
    $canEdit = $client->check(
        tupleKey: tuple($userId, 'editor', $documentId)
    )->unwrap();

    echo "Can edit: " . ($canEdit->getAllowed() ? 'Yes' : 'No') . "\n";

    // Show the permission tree
    $tree = $client->expand(
        tupleKey: new TupleKey(relation: 'editor', object: $documentId)
    )->unwrap();

    echo "Permission structure:\n";
    print_r($tree->toArray());

    // List all relationships for this document
    $allTuples = $client->readTuples(
        tupleKey: new TupleKey(object: $documentId)
    )->unwrap();

    echo "All permissions:\n";
    foreach ($allTuples->getTuples() as $tuple) {
        echo "- {$tuple->getUser()} {$tuple->getRelation()}\n";
    }
}
```

##### What's next?

Now that you can query permissions effectively:

**Essential next steps:**

- **[Results →](Results.md)** - Handle errors gracefully in production
- **[Tuples →](Tuples.md)** - Learn to grant and revoke permissions
- **[Models →](Models.md)** - Build more sophisticated permission rules

**Advanced topics:**

- **[Assertions →](Assertions.md)** - Test your permission logic automatically
- **[Concurrency →](Concurrency.md)** - Optimize batch operations
- **[Observability →](Observability.md)** - Monitor query performance


### Testing with Assertions

#### Testing Your Authorization Model

Think of assertions as unit tests for your permission system. They let you define what should and shouldn't be allowed, then verify your authorization model works correctly before deploying it to production.

##### Prerequisites

Before working with assertions, ensure you have the following setup:

```php
use OpenFGA\Client;
use OpenFGA\Models\Assertion;
use OpenFGA\Collections\Assertions;
use function OpenFGA\{tuple, tuples};

// Initialize the client
$client = new Client(url: $_ENV['FGA_API_URL']);

// These variables are used throughout the examples
$storeId = 'your-store-id';
$modelId = 'your-authorization-model-id';
```

##### What are assertions?

Assertions are test cases that specify expected outcomes for permission checks. Each assertion says "user X should (or shouldn't) have permission Y on resource Z" and verifies this against your authorization model.

##### Writing your first test

Let's say you're building a document management system. You want to test that owners can edit documents but viewers cannot:

```php
// Test: Document owners can edit
$ownerCanEdit = new Assertion(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'can_edit',
        object: 'document:quarterly-report'
    ),
    expectation: true
);

// Test: Viewers cannot edit
$viewerCannotEdit = new Assertion(
    tupleKey: tuple(
        user: 'user:bob',
        relation: 'can_edit',
        object: 'document:quarterly-report'
    ),
    expectation: false
);

$tests = new Assertions([$ownerCanEdit, $viewerCannotEdit]);

$client->writeAssertions(
    store: $storeId,
    model: $modelId,
    assertions: $tests
)->unwrap();
```

##### Testing permission inheritance

Complex authorization models often have inherited permissions. Test these relationships to ensure they work as expected:

```php
// In a team workspace, team members inherit folder permissions
$teamFolderAccess = [
    // Direct team member access
    new Assertion(
        tupleKey: tuple('user:sarah', 'can_read', 'folder:team-docs'),
        expectation: true
    ),

    // Inherited document access through folder membership
    new Assertion(
        tupleKey: tuple('user:sarah', 'can_read', 'document:team-meeting-notes'),
        expectation: true
    ),

    // Non-team members should be denied
    new Assertion(
        tupleKey: tuple('user:outsider', 'can_read', 'folder:team-docs'),
        expectation: false
    ),
];
```

##### Testing edge cases

Test boundary conditions and special cases in your permission model:

```php
$edgeCases = [
    // Public documents should be readable by anyone
    new Assertion(
        tupleKey: tuple('user:*', 'can_read', 'document:company-handbook'),
        expectation: true
    ),

    // Deleted users should lose all access
    new Assertion(
        tupleKey: tuple('user:former-employee', 'can_read', 'document:confidential'),
        expectation: false
    ),

    // Admin override permissions
    new Assertion(
        tupleKey: tuple('user:admin', 'can_delete', 'document:any-document'),
        expectation: true
    ),

    // Cross-organization access should be blocked
    new Assertion(
        tupleKey: tuple('user:competitor', 'can_read', 'document:internal-strategy'),
        expectation: false
    ),
];
```

##### Managing test data

Organize your assertions logically and keep them maintainable:

```php
class DocumentPermissionTests
{
    public static function getBasicPermissions(): array
    {
        return [
            // Owner permissions
            new Assertion(tuple('user:owner', 'can_read', 'document:doc1'), true),
            new Assertion(tuple('user:owner', 'can_edit', 'document:doc1'), true),
            new Assertion(tuple('user:owner', 'can_delete', 'document:doc1'), true),

            // Editor permissions
            new Assertion(tuple('user:editor', 'can_read', 'document:doc1'), true),
            new Assertion(tuple('user:editor', 'can_edit', 'document:doc1'), true),
            new Assertion(tuple('user:editor', 'can_delete', 'document:doc1'), false),

            // Viewer permissions
            new Assertion(tuple('user:viewer', 'can_read', 'document:doc1'), true),
            new Assertion(tuple('user:viewer', 'can_edit', 'document:doc1'), false),
            new Assertion(tuple('user:viewer', 'can_delete', 'document:doc1'), false),
        ];
    }

    public static function getInheritanceTests(): array
    {
        return [
            // Team lead inherits team permissions
            new Assertion(tuple('user:team-lead', 'can_manage', 'team:engineering'), true),
            new Assertion(tuple('user:team-lead', 'can_read', 'document:team-roadmap'), true),
        ];
    }
}

// Write different test suites
$client->writeAssertions(
    store: $storeId,
    model: $modelId,
    assertions: new Assertions([
        ...DocumentPermissionTests::getBasicPermissions(),
        ...DocumentPermissionTests::getInheritanceTests(),
    ])
)->unwrap();
```

##### Best practices

**Start with critical paths**: Test the most important permission checks first - admin access, user data privacy, billing permissions.

**Test both positive and negative cases**: Don't just test what should work, test what should be blocked.

**Use realistic data**: Test with actual user IDs, resource names, and permission types from your application.

**Update tests when models change**: Assertions should evolve with your authorization model. Treat them like any other test suite.

**Validate before deployment**: Run assertions in your CI/CD pipeline to catch permission regressions before they reach production.

```php
// Reading existing assertions for review
$response = $client->readAssertions(
    store: $storeId,
    model: $modelId,
)->unwrap();

foreach ($response->getAssertions() as $assertion) {
    $key = $assertion->getTupleKey();
    $expected = $assertion->getExpectation() ? 'CAN' : 'CANNOT';

    echo "{$key->getUser()} {$expected} {$key->getRelation()} {$key->getObject()}\n";
}
```

Remember: assertions replace all existing tests for a model when you call `writeAssertions()`. Always include your complete test suite in each call.


### Result Pattern and Error Handling

#### Results

##### Prerequisites

The examples in this guide assume you have the following setup:

```php
use OpenFGA\Sdk\{Client, ClientInterface};
use OpenFGA\Sdk\Model\{Store, Configuration};
use OpenFGA\Exceptions\{ClientError, ClientException, NetworkError, NetworkException};
use function OpenFGA\{result, ok, err, unwrap, success, failure, tuple, allowed};

// Initialize client
$client = new Client(url: 'http://localhost:8080');

// These values are typically from your configuration or previous operations
$storeId = 'your-store-id';
$modelId = 'your-model-id';
$store = $client->getStore($storeId)->unwrap();
$model = $client->getAuthorizationModel($storeId, $modelId)->unwrap();

// For Laravel users - the collect() function is available
// For non-Laravel users, you can use array_map/array_filter or similar
```

##### Why use Results?

Tired of wrapping every API call in try-catch blocks? The OpenFGA SDK uses Results to make error handling explicit and chainable:

```php
// Instead of this mess:
try {
    $store = $client->getStore($storeId);
    try {
        $model = $client->getAuthorizationModel($store->getId(), $modelId);
        // Do something with $model
    } catch (Exception $e) {
        // Handle model error
    }
} catch (Exception $e) {
    // Handle store error
}

// You get this:
$client->getStore($storeId)
    ->then(fn($store) => $client->getAuthorizationModel($store->getId(), $modelId))
    ->success(fn($model) => $this->processModel($model))
    ->failure(fn($error) => $this->logError($error));
```

All SDK methods return either `Success` or `Failure` objects instead of throwing exceptions for expected failures like "not found" or validation errors.

##### Basic usage

The most common patterns you'll need:

###### Just get the value

```php
// Get the value or throw on failure
$store = $client->getStore($storeId)->unwrap();

// Get the value with a fallback
$store = $client->getStore($storeId)->unwrap(
    fn($error) => Store::default()
);
```

###### Handle success and failure

```php
$result = $client->createStore(name: 'my-store');

$result
    ->success(fn($store) => logger()->info("Created store: {$store->getId()}"))
    ->failure(fn($error) => logger()->error("Failed: {$error->getMessage()}"));
```

###### Check the outcome

```php
if ($result->succeeded()) {
    $store = $result->unwrap();
    // Do something with $store
}

if ($result->failed()) {
    $error = $result->err();
    // Handle the error
}
```

##### Chaining operations

Results really shine when you need to chain multiple operations:

###### Transform success values with `then()`

```php
$result = $client->getStore($storeId)
    ->then(fn($store) => $client->getAuthorizationModel($store->getId(), $modelId))
    ->then(fn($model) => $this->processModel($model));
```

###### Provide fallbacks with `recover()`

```php
$config = $client->getStore($storeId)
    ->then(fn($store) => $store->getConfiguration())
    ->recover(fn($error) => Configuration::default())
    ->unwrap();
```

###### Pipeline with side effects

```php
$tuples = [/* your tuples here */];

$client->writeTuples($store, $model, $tuples)
    ->success(fn($response) => $this->logSuccess($response))
    ->failure(fn($error) => $this->logError($error))
    ->then(fn($response) => $this->notifyWebhooks($response))
    ->recover(fn($error) => $this->handleFailure($error));
```

##### Error handling patterns

###### Fail gracefully with helper functions

```php
// Return a sensible default when things go wrong
function getUserPermissions(string $userId): array
{
    return result(function() use ($userId) {
        return $this->client->listObjects(
            user: $userId,
            relation: 'can_access'
        );
    })
    ->then(fn($response) => $response->getObjects())
    ->recover(function(Throwable $error) {
        logger()->warning('Failed to get user permissions', [
            'error_type' => $error::class,
            'message' => $error->getMessage()
        ]);
        return []; // Empty permissions on error
    })
    ->unwrap();
}
```

###### Handling specific error types with enum-based exceptions

```php
function canUserAccess(string $userId, string $documentId): bool
{
    // Call client->check() to get a ResultInterface object
    $result = $this->client->check(
        store: $this->storeId,
        model: $this->modelId,
        tupleKey: tuple("user:{$userId}", 'viewer', "document:{$documentId}")
    );

    // Check if the operation failed
    if ($result->failed()) {
        $error = $result->err(); // Get the actual error/exception

        // Handle specific enum-based ClientException errors
        if ($error instanceof ClientException) {
            return match($error->getError()) { // getError() returns the enum
                // Network errors can be retried
                ClientError::Network => $this->retryAfterDelay(function() use ($userId, $documentId) {
                    // Recursive call or re-attempt logic
                    return $this->canUserAccess($userId, $documentId);
                }, $maxRetries = 3),

                // Authentication errors should trigger re-auth
                ClientError::Authentication => $this->handleAuthError($error), // Pass the error object

                // Fall back to cached permissions for other client errors
                default => $this->getCachedPermission($userId, $documentId, false)
            };
        }

        // Handle other types of Throwable or log unexpected errors
        logger()->error('Unexpected error checking permissions', [
            'error_type' => $error::class,
            'message' => $error->getMessage(),
            'user' => $userId,
            'document' => $documentId
        ]);

        return false; // Secure default for unhandled errors
    }

    // If successful, unwrap to get the CheckResponse and then getAllowed()
    return $result->unwrap()->getAllowed();
}
```

###### Collect multiple results

```php
$userId = 'user:anne';
$resourceId = 'document:budget-2024';

$permissions = collect(['read', 'write', 'delete'])
    ->map(fn($action) => $client->check(user: $userId, relation: $action, object: $resourceId))
    ->filter(fn($result) => $result->succeeded())
    ->map(fn($result) => $result->unwrap()->getAllowed())
    ->toArray();
```

###### Add context to errors

```php
$tuples = [/* your tuples here */];

$result = $client->writeTuples($store, $model, $tuples)
    ->failure(function(Throwable $e) use ($store, $tuples) {
        logger()->error("Failed to write tuples to store {$store->getId()}", [
            'error' => $e->getMessage(),
            'tuples_count' => count($tuples)
        ]);
    });
```

###### Convert errors to application exceptions

```php
$model = $client->getAuthorizationModel($storeId, $modelId)
    ->recover(fn($error) => throw new ModelNotFoundException($modelId, previous: $error))
    ->unwrap();
```

##### Advanced patterns

###### Retry with exponential backoff

```php
function checkWithRetry(string $user, string $relation, string $object): bool
{
    return retry(3, function() use ($user, $relation, $object) {
        return $this->client->check(
            user: $user,
            relation: $relation,
            object: $object
        )->unwrap()->getAllowed();
    }, sleepMilliseconds: fn($attempt) => $attempt * 1000);
}
```

###### Batch operations with partial failures

```php
function batchCheck(array $checks): array
{
    return collect($checks)
        ->map(fn($check) => $this->client->check(...$check))
        ->map(fn($result, $index) => [
            'index' => $index,
            'allowed' => $result->succeeded() && $result->unwrap()->getAllowed(),
            'error' => $result->failed() ? $result->err()->getMessage() : null
        ])
        ->toArray();
}
```

###### Framework integration

###### Laravel Service

```php
// Note: This is an example helper class for a Laravel application and not part of the SDK.
class PermissionService
{
    public function __construct(
        private ClientInterface $client,
        private string $storeId,
        private string $modelId
    ) {}

    public function can(string $user, string $action, string $resource): bool
    {
        return $this->client
            ->check(
                store: $this->storeId,
                model: $this->modelId,
                tupleKey: tuple($user, $action, $resource)
            )
            ->then(fn($response) => $response->getAllowed())
            ->recover(function(Throwable $e) {
                Log::warning('Permission check failed', [
                    'user' => $user,
                    'action' => $action,
                    'resource' => $resource,
                    'error' => $e->getMessage()
                ]);
                return false; // Fail closed
            })
            ->unwrap();
    }
}
```

###### Symfony Voter

```php
class FgaVoter extends Voter
{
    protected function voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token): bool
    {
        return $this->client
            ->check(
                store: $this->store,
                model: $this->model,
                tupleKey: tuple($token->getUserIdentifier(), $attribute, $subject->getId())
            )
            ->then(fn($response) => $response->getAllowed())
            ->recover(fn() => false) // Deny on error
            ->unwrap();
    }
}
```

##### When to use what

- **`unwrap()`** - When you want simple exception-based error handling
- **`success()` / `failure()`** - For side effects like logging without changing the result
- **`then()`** - To transform success values or chain operations
- **`recover()`** - To provide fallbacks or convert failures to successes

The Result pattern makes error handling explicit and composable. Chain operations confidently knowing failures won't break your pipeline.


### Monitoring and Telemetry

#### OpenTelemetry Observability with the OpenFGA PHP SDK

The OpenFGA PHP SDK includes comprehensive OpenTelemetry support for observability, providing distributed tracing, metrics collection, and telemetry data to help you monitor, debug, and optimize your authorization workflows. Whether you're troubleshooting performance issues or gaining insights into your application's authorization patterns, the SDK's telemetry features give you the visibility you need.

**New to OpenTelemetry?** It's an open-source observability framework that helps you collect, process, and export telemetry data (metrics, logs, and traces) from your applications. Think of it as a way to understand what your application is doing under the hood.

**Already using OpenTelemetry?** The SDK integrates seamlessly with your existing setup - just configure your telemetry provider and start getting insights into your OpenFGA operations automatically.

##### Table of Contents

- [What You'll Get](#what-youll-get)
- [Prerequisites](#prerequisites)
- [Quick Start](#quick-start)
- [Telemetry Data Collected](#telemetry-data-collected)
- [Configuration Options](#configuration-options)
- [Common Integration Patterns](#common-integration-patterns)
- [Example: Complete Authorization Workflow with Tracing](#example-complete-authorization-workflow-with-tracing)
- [Viewing Your Telemetry Data](#viewing-your-telemetry-data)
- [Troubleshooting](#troubleshooting)
- [Event-Driven Telemetry](#event-driven-telemetry)
- [Advanced Usage](#advanced-usage)
- [Next Steps](#next-steps)

##### What You'll Get

The SDK automatically instruments and provides telemetry for:

- **HTTP Requests:** All API calls to OpenFGA, including timing, status codes, and errors
- **OpenFGA Operations:** Business-level operations like `check()`, `listObjects()`, `writeTuples()`, etc.
- **Retry Logic:** Failed requests, retry attempts, and backoff delays
- **Circuit Breaker:** State changes and failure rate tracking
- **Authentication:** Token requests, refreshes, and authentication events

##### Prerequisites

All examples in this guide assume the following setup:

**Requirements:**
- **PHP 8.3+** with the OpenFGA PHP SDK installed
- **OpenTelemetry PHP packages** (optional, but recommended for full functionality):
  ```bash
  composer require open-telemetry/api open-telemetry/sdk
  ```
- **An observability backend** like Jaeger, Zipkin, or a cloud service (optional for getting started)

**Common imports and setup code:**

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

// OpenFGA SDK imports
use OpenFGA\Client;
use OpenFGA\Observability\TelemetryFactory;

// OpenTelemetry imports (when using full OpenTelemetry setup)
use OpenTelemetry\API\Globals;
use OpenTelemetry\API\Trace\Propagation\TraceContextPropagator;
use OpenTelemetry\API\Trace\Span;
use OpenTelemetry\Contrib\Otlp\SpanExporter;
use OpenTelemetry\SDK\Trace\SpanProcessor\SimpleSpanProcessor;
use OpenTelemetry\SDK\Trace\TracerProvider;

// Event-driven telemetry imports
use OpenFGA\Events\{
    EventDispatcher,
    HttpRequestSentEvent,
    HttpResponseReceivedEvent,
    OperationCompletedEvent,
    OperationStartedEvent
};

// Helper functions for common operations
use function OpenFGA\{allowed, dsl, model, store, tuple, tuples, write};

// Basic client configuration (customize for your environment)
$apiUrl = $_ENV['FGA_API_URL'] ?? 'http://localhost:8080';
$storeId = 'your-store-id';
$modelId = 'your-model-id';
```

##### Quick Start

###### 1. Basic Setup (No Backend)

The simplest way to get started is with the built-in telemetry that works without any external dependencies:

```php
// Create a telemetry provider
$telemetry = TelemetryFactory::create(
    serviceName: 'my-authorization-service',
    serviceVersion: '1.0.0'
);

// Configure the client with telemetry
$client = new Client(
    url: $apiUrl,
    telemetry: $telemetry
);

// Your authorization operations are now automatically instrumented!
$result = $client->check(
    store: $storeId,
    model: $modelId,
    tupleKey: tuple(user: 'user:anne', relation: 'viewer', object: 'document:readme')
);
```

###### 2. Full OpenTelemetry Setup

For production use with a telemetry backend, install the OpenTelemetry packages and configure them:

```bash
composer require open-telemetry/api open-telemetry/sdk
```

```php
// Configure OpenTelemetry (this is a basic example)
$tracerProvider = new TracerProvider([
    new SimpleSpanProcessor(
        new SpanExporter($_ENV['OTEL_EXPORTER_OTLP_ENDPOINT'] ?? 'http://localhost:4317')
    )
]);

Globals::registerInitializer(function () use ($tracerProvider) {
    return \OpenTelemetry\SDK\Registry::get()->tracerProvider($tracerProvider);
});

// Create telemetry with your service information
$telemetry = TelemetryFactory::create(
    serviceName: 'my-authorization-service',
    serviceVersion: '1.2.3'
);

// Configure client
$client = new Client(
    url: $apiUrl,
    telemetry: $telemetry
);

// Operations are now traced and exported to your backend
$result = $client->listObjects(
    store: $storeId,
    model: $modelId,
    user: 'user:anne',
    relation: 'viewer',
    type: 'document'
);
```

##### Telemetry Data Collected

###### HTTP Request Telemetry

Every HTTP request to the OpenFGA API is automatically instrumented:

**Traces (Spans):**

- Span name: `HTTP {METHOD}` (for example `HTTP POST`)
- Duration of the entire HTTP request/response cycle
- HTTP method, URL, status code, response size
- Error details if the request fails

**Metrics:**

- `openfga.http.requests.total` - Counter of HTTP requests by method, status code, and success/failure

**Example span attributes:**

```
http.method: POST
http.url: https://api.fga.example/stores/123/check
http.scheme: https
http.host: api.fga.example
http.status_code: 200
http.response.size: 1024
openfga.sdk.name: openfga-php
openfga.sdk.version: 1.0.0
```

###### OpenFGA Operation Telemetry

Business-level operations provide higher-level observability:

**Traces (Spans):**

- Span name: `openfga.{operation}` (for example `openfga.check`, `openfga.write_tuples`)
- Duration of the business operation (may include multiple HTTP calls)
- Store ID, model ID, and operation-specific metadata

**Metrics:**

- `openfga.operations.total` - Counter of operations by type, store, success/failure
- `openfga.operations.duration` - Histogram of operation durations

**Example operation span:**

```
openfga.operation: check
openfga.store_id: store_01H1234567890ABCDEF
openfga.model_id: model_01H1234567890ABCDEF
openfga.sdk.name: openfga-php
openfga.sdk.version: 1.0.0
```

###### Retry and Reliability Telemetry

The SDK automatically tracks retry attempts and circuit breaker behavior:

**Retry Metrics:**

- `openfga.retries.total` - Counter of retry attempts by endpoint and outcome
- `openfga.retries.delay` - Histogram of retry delays in milliseconds

**Circuit Breaker Metrics:**

- `openfga.circuit_breaker.state_changes.total` - Counter of state changes (open/closed)

**Authentication Telemetry:**

- `openfga.auth.events.total` - Counter of authentication events
- `openfga.auth.duration` - Histogram of authentication operation durations

##### Configuration Options

###### Service Identification

Configure your service information for better observability:

```php
$telemetry = TelemetryFactory::create(
    serviceName: 'user-management-api',     // Your service name
    serviceVersion: '2.1.0'                 // Your service version
);
```

###### Custom Telemetry Providers

You can provide your own configured OpenTelemetry tracer and meter:

```php
// Get your configured tracer and meter
$tracer = Globals::tracerProvider()->getTracer('my-service', '1.0.0');
$meter = Globals::meterProvider()->getMeter('my-service', '1.0.0');

// Create telemetry with custom providers
$telemetry = TelemetryFactory::createWithCustomProviders($tracer, $meter);

$client = new Client(
    url: $apiUrl,
    telemetry: $telemetry
);
```

###### No-Op Mode

For testing or when you want to disable telemetry:

```php
// Explicitly disable telemetry
$telemetry = TelemetryFactory::createNoOp(); // Returns null

$client = new Client(
    url: $apiUrl,
    telemetry: $telemetry
);

// Or simply pass null directly
$client = new Client(
    url: $apiUrl,
    telemetry: null  // No telemetry
);
```

##### Common Integration Patterns

###### Jaeger (Local Development)

For local development with Jaeger:

```bash
#### Start Jaeger with Docker
docker run -d --name jaeger \
  -p 16686:16686 \
  -p 14250:14250 \
  jaegertracing/all-in-one:latest
```

```php
use OpenTelemetry\Contrib\Jaeger\Exporter as JaegerExporter;

$tracerProvider = new TracerProvider([
    new SimpleSpanProcessor(
        new JaegerExporter(
            'my-service',
            'http://localhost:14268/api/traces'
        )
    )
]);

Globals::registerInitializer(function () use ($tracerProvider) {
    return \OpenTelemetry\SDK\Registry::get()->tracerProvider($tracerProvider);
});

$telemetry = TelemetryFactory::create('my-service', '1.0.0');
```

###### Cloud Providers

For cloud-based observability services:

```php
// AWS X-Ray, Google Cloud Trace, Azure Monitor, etc.
$exporter = new SpanExporter($_ENV['OTEL_EXPORTER_OTLP_ENDPOINT']);
// Configure with your cloud provider's specific settings
```

###### Existing OpenTelemetry Setup

If you already have OpenTelemetry configured in your application:

```php
// The SDK will automatically use your existing global configuration
$telemetry = TelemetryFactory::create('my-authorization-service');

$client = new Client(
    url: $apiUrl,
    telemetry: $telemetry
);

// Traces will be included in your existing observability setup
```

##### Example: Complete Authorization Workflow with Tracing

Here's a complete example showing how telemetry works throughout an authorization workflow:

```php
// Configure telemetry (assumes OpenTelemetry is set up)
$telemetry = TelemetryFactory::create(
    serviceName: 'document-service',
    serviceVersion: '1.0.0'
);

$client = new Client(
    url: $apiUrl,
    telemetry: $telemetry
);

try {
    // Each operation creates its own span with timing and metadata

    // 1. Create store - traced as "openfga.create_store"
    $store = $client->createStore(name: 'document-service-store')
        ->unwrap();

    // 2. Create model - traced as "openfga.create_authorization_model"
    $model = $client->createAuthorizationModel(
        store: $store->getId(),
        typeDefinitions: $authModel->getTypeDefinitions()
    )->unwrap();

    // 3. Write relationships - traced as "openfga.write_tuples"
    $client->writeTuples(
        store: $store->getId(),
        model: $model->getId(),
        writes: tuples(
            tuple(user: 'user:anne', relation: 'viewer', object: 'document:readme'),
            tuple(user: 'user:bob', relation: 'editor', object: 'document:readme')
        )
    )->unwrap();

    // 4. Check authorization - traced as "openfga.check"
    $allowed = $client->check(
        store: $store->getId(),
        model: $model->getId(),
        tupleKey: tuple(user: 'user:anne', relation: 'viewer', object: 'document:readme')
    )->unwrap();

    // 5. List accessible objects - traced as "openfga.list_objects"
    $documents = $client->listObjects(
        store: $store->getId(),
        model: $model->getId(),
        user: 'user:anne',
        relation: 'viewer',
        type: 'document'
    )->unwrap();

    echo "Authorization check complete. Anne can view document: " .
         ($allowed->getAllowed() ? 'Yes' : 'No') . "\n";
    echo "Documents Anne can view: " . count($documents->getObjects()) . "\n";

} catch (Throwable $e) {
    // Errors are automatically recorded in spans
    echo "Authorization failed: " . $e->getMessage() . "\n";
}
```

##### Viewing Your Telemetry Data

###### In Jaeger UI

1. Open http://localhost:16686 in your browser
2. Select your service name from the dropdown
3. Click "Find Traces" to see recent authorization operations
4. Click on a trace to see the detailed span timeline

###### Key Things to Look For

**Performance Analysis:**

- Which operations take the longest?
- Are there patterns in slow requests?
- How do retry attempts affect overall timing?

**Error Investigation:**

- What HTTP status codes are you getting?
- Which OpenFGA operations are failing?
- Are authentication issues causing problems?

**Usage Patterns:**

- Which stores and models are accessed most frequently?
- What types of authorization checks are most common?
- How often do retries occur?

##### Troubleshooting

###### No Telemetry Data

1. **Check if OpenTelemetry is properly installed:**

   ```bash
   composer show | grep open-telemetry
   ```

2. **Verify your exporter configuration:**

   ```php
   // Add debug output
   $telemetry = TelemetryFactory::create('test-service');
   if ($telemetry instanceof \OpenFGA\Observability\OpenTelemetryProvider) {
       echo "Using OpenTelemetry provider\n";
   } elseif ($telemetry === null) {
       echo "No telemetry configured\n";
   }
   ```

3. **Check your backend connectivity:**
   - Ensure your OTLP endpoint is reachable
   - Verify authentication if required
   - Check firewall and network settings

###### Performance Impact

The telemetry overhead is minimal in production:

- **No-op mode:** Virtually zero overhead when telemetry is disabled
- **OpenTelemetry mode:** Low overhead (~1-2% typically) with async exporters
- **Graceful degradation:** Continues working even if telemetry backend is unavailable

###### Environment Variables

Common OpenTelemetry environment variables that work with the SDK:

```bash
#### Service identification
export OTEL_SERVICE_NAME="my-authorization-service"
export OTEL_SERVICE_VERSION="1.0.0"

#### Exporter configuration
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"
export OTEL_EXPORTER_OTLP_HEADERS="api-key=your-api-key"

#### Sampling (to reduce overhead in high-traffic scenarios)
export OTEL_TRACES_SAMPLER="traceidratio"
export OTEL_TRACES_SAMPLER_ARG="0.1"  # Sample 10% of traces
```

##### Event-Driven Telemetry

The SDK provides a powerful event-driven telemetry system that allows you to create custom observability solutions without tight coupling to the main client functionality. This approach lets you build specialized listeners for different concerns like logging, metrics collection, alerting, or custom analytics.

###### Available Events

The SDK emits events at key points during operation execution:

- **`OperationStartedEvent`** - When an OpenFGA operation begins (check, write, etc.)
- **`OperationCompletedEvent`** - When an operation finishes (success or failure)
- **`HttpRequestSentEvent`** - When HTTP requests are sent to the OpenFGA API
- **`HttpResponseReceivedEvent`** - When HTTP responses are received

###### Creating Custom Event Listeners

Here's how to create and register custom event listeners:

```php
// Create a logging listener
// Note: This is an example helper class and not part of the SDK.
final class LoggingEventListener
{
    public function onHttpRequestSent(HttpRequestSentEvent $event): void
    {
        echo "[{$event->getOperation()}] HTTP Request: {$event->getRequest()->getMethod()} {$event->getRequest()->getUri()}\n";
    }

    public function onHttpResponseReceived(HttpResponseReceivedEvent $event): void
    {
        $status = $event->getResponse() ? $event->getResponse()->getStatusCode() : 'N/A';
        $success = $event->isSuccessful() ? '✅' : '❌';
        echo "[{$event->getOperation()}] HTTP Response: {$success} {$status}\n";
    }

    public function onOperationStarted(OperationStartedEvent $event): void
    {
        echo "[{$event->getOperation()}] Started - Store: {$event->getStoreId()}\n";
    }

    public function onOperationCompleted(OperationCompletedEvent $event): void
    {
        $success = $event->isSuccessful() ? '✅' : '❌';
        echo "[{$event->getOperation()}] Completed: {$success}\n";
    }
}

// Create a metrics listener
// Note: This is an example helper class and not part of the SDK.
final class MetricsEventListener
{
    private array $operationTimes = [];
    private array $requestCounts = [];

    public function onOperationStarted(OperationStartedEvent $event): void
    {
        $this->operationTimes[$event->getEventId()] = microtime(true);
    }

    public function onOperationCompleted(OperationCompletedEvent $event): void
    {
        $operation = $event->getOperation();

        // Count operations
        $this->requestCounts[$operation] = ($this->requestCounts[$operation] ?? 0) + 1;

        // Track timing
        if (isset($this->operationTimes[$event->getEventId()])) {
            $duration = microtime(true) - $this->operationTimes[$event->getEventId()];
            echo "[{$operation}] completed in " . round($duration * 1000, 2) . "ms\n";
            unset($this->operationTimes[$event->getEventId()]);
        }
    }

    public function getMetrics(): array
    {
        return [
            'request_counts' => $this->requestCounts,
            'active_operations' => count($this->operationTimes),
        ];
    }
}
```

###### Registering Event Listeners

Register your listeners with the event dispatcher:

```php
// Create event dispatcher and listeners
$eventDispatcher = new EventDispatcher();
$loggingListener = new LoggingEventListener();
$metricsListener = new MetricsEventListener();

// Register listeners for different events
$eventDispatcher->addListener(HttpRequestSentEvent::class, [$loggingListener, 'onHttpRequestSent']);
$eventDispatcher->addListener(HttpResponseReceivedEvent::class, [$loggingListener, 'onHttpResponseReceived']);
$eventDispatcher->addListener(OperationStartedEvent::class, [$loggingListener, 'onOperationStarted']);
$eventDispatcher->addListener(OperationCompletedEvent::class, [$loggingListener, 'onOperationCompleted']);

// Register metrics listener
$eventDispatcher->addListener(OperationStartedEvent::class, [$metricsListener, 'onOperationStarted']);
$eventDispatcher->addListener(OperationCompletedEvent::class, [$metricsListener, 'onOperationCompleted']);

// Note: In production, you would configure the event dispatcher through dependency injection
// The above example shows the concept for educational purposes
```

###### Complete Event-Driven Example

Here's a complete example showing event-driven telemetry in action:

```php
// Your custom listeners (defined above)
$eventDispatcher = new EventDispatcher();
$loggingListener = new LoggingEventListener();
$metricsListener = new MetricsEventListener();

// Register all listeners
$eventDispatcher->addListener(HttpRequestSentEvent::class, [$loggingListener, 'onHttpRequestSent']);
$eventDispatcher->addListener(HttpResponseReceivedEvent::class, [$loggingListener, 'onHttpResponseReceived']);
$eventDispatcher->addListener(OperationStartedEvent::class, [$loggingListener, 'onOperationStarted']);
$eventDispatcher->addListener(OperationCompletedEvent::class, [$loggingListener, 'onOperationCompleted']);
$eventDispatcher->addListener(OperationStartedEvent::class, [$metricsListener, 'onOperationStarted']);
$eventDispatcher->addListener(OperationCompletedEvent::class, [$metricsListener, 'onOperationCompleted']);

$client = new Client(
    url: $apiUrl,
    eventDispatcher: $eventDispatcher,
);

// Perform operations - events will be triggered automatically
$storeId = store($client, 'telemetry-demo');

$authModel = dsl($client, '
    model
      schema 1.1
    type user
    type document
      relations
        define viewer: [user]
');
$modelId = model($client, $storeId, $authModel);

write($client, $storeId, $modelId, tuple('user:alice', 'viewer', 'document:report'));
$canView = allowed($client, $storeId, $modelId, tuple('user:alice', 'viewer', 'document:report'));

// View collected metrics
echo "Collected Metrics:\n";
print_r($metricsListener->getMetrics());
```

###### Production Use Cases

**Custom Alerting:**

```php
// Note: This is an example helper class and not part of the SDK.
final class AlertingEventListener
{
    public function onOperationCompleted(OperationCompletedEvent $event): void
    {
        if (!$event->isSuccessful()) {
            // Send alert to your monitoring system
            $this->sendAlert([
                'operation' => $event->getOperation(),
                'store_id' => $event->getStoreId(),
                'error' => $event->getException()?->getMessage(),
            ]);
        }
    }
}
```

**Security Monitoring:**

```php
// Note: This is an example helper class and not part of the SDK.
final class SecurityEventListener
{
    public function onOperationStarted(OperationStartedEvent $event): void
    {
        if ($event->getOperation() === 'check') {
            // Log authorization attempts for security analysis
            $this->logSecurityEvent([
                'timestamp' => time(),
                'operation' => $event->getOperation(),
                'store_id' => $event->getStoreId(),
                'user_ip' => $_SERVER['REMOTE_ADDR'] ?? 'unknown',
            ]);
        }
    }
}
```

**Performance Analytics:**

```php
// Note: This is an example helper class and not part of the SDK.
final class PerformanceEventListener
{
    private array $operationTimings = [];

    public function onOperationCompleted(OperationCompletedEvent $event): void
    {
        $timing = $this->calculateTiming($event);

        // Export to your analytics platform
        $this->exportToAnalytics([
            'operation' => $event->getOperation(),
            'duration_ms' => $timing,
            'store_id' => $event->getStoreId(),
            'success' => $event->isSuccessful(),
        ]);
    }
}
```

###### Benefits of Event-Driven Telemetry

- **Decoupling:** Observability logic is separate from business logic
- **Flexibility:** Add multiple listeners for the same events
- **Specialization:** Create focused listeners for different concerns
- **Testability:** Easy to unit test telemetry functionality in isolation
- **Extensibility:** Add new observability features without changing core code
- **Custom Integration:** Perfect for integrating with proprietary monitoring systems

###### Integration with Dependency Injection

In production applications, register listeners through your DI container:

```php
// In your service provider or DI configuration
$container->singleton(EventDispatcher::class, function () {
    $dispatcher = new EventDispatcher();

    // Register all your listeners
    $dispatcher->addListener(OperationStartedEvent::class, [LoggingEventListener::class, 'onOperationStarted']);
    $dispatcher->addListener(OperationCompletedEvent::class, [MetricsEventListener::class, 'onOperationCompleted']);
    // ... more listeners

    return $dispatcher;
});

// Configure the client to use the dispatcher
$container->singleton(Client::class, function ($container) {
    return new Client(
        url: $apiUrl,
        eventDispatcher: $container->get(EventDispatcher::class),
    );
});
```

##### Advanced Usage

###### Custom Attributes

Add custom context to your authorization operations:

```php
// The SDK automatically includes relevant attributes, but you can add more context
// when configuring your service or through OpenTelemetry's context propagation

// Add custom attributes to the current span
$span = Span::getCurrent();
$span->setAttribute('user.department', 'engineering');
$span->setAttribute('request.source', 'mobile-app');

// Now perform your authorization check
$result = $client->check(
    store: $storeId,
    model: $modelId,
    tupleKey: tuple(user: 'user:anne', relation: 'viewer', object: 'document:readme')
);
```

###### Correlation with Application Traces

The SDK integrates with your application's existing traces:

```php
// If you have an existing span (for example from a web request)
$parentSpan = $yourFramework->getCurrentSpan();

// OpenFGA operations will automatically become child spans
$result = $client->check(
    store: $storeId,
    model: $modelId,
    tupleKey: tuple(user: 'user:anne', relation: 'viewer', object: 'document:readme')
); // This becomes a child of $parentSpan
```

###### Metrics-Only Mode

If you only want metrics without distributed tracing:

```php
// Configure OpenTelemetry with metrics only
use OpenTelemetry\SDK\Metrics\MeterProvider;

$meterProvider = new MeterProvider(/* your exporters */);
// Don't configure a tracer provider

$telemetry = TelemetryFactory::create('my-service');
```

##### Next Steps

**Getting Started:**

- Try the basic setup with your existing OpenFGA instance
- Add Jaeger for local development to see traces immediately
- Review the [Introduction.md](Introduction.md) guide for basic OpenFGA usage
- Run the [event-driven telemetry example](../examples/event-driven-telemetry/example.php) to see custom listeners in action

**Production Setup:**

- Configure proper sampling rates for high-traffic applications
- Set up dashboards in your observability platform
- Implement alerting on key metrics like error rates and latency
- Consider event-driven telemetry for custom monitoring integrations

**Integration:**

- Explore the [Authentication.md](Authentication.md) guide for secure telemetry
- Read about [Results.md](Results.md) for error handling patterns that work well with observability
- Check [Queries.md](Queries.md) for the operations you'll be monitoring

**Examples:**

- [OpenTelemetry observability example](../examples/observability/example.php) - Complete OpenTelemetry setup
- [Event-driven telemetry example](../examples/event-driven-telemetry/example.php) - Custom event listeners
- [All observability examples](../examples/README.md) - Complete collection

For more details on the OpenTelemetry ecosystem, visit the [official OpenTelemetry documentation](https://opentelemetry.io/docs/).


## API Reference Documentation

Complete API documentation is available in the `/docs/API/` directory. Here's the organized structure:

### Core Classes

- [Main OpenFGA client with all operations](docs/API/Client.md)
- [Client interface definition](docs/API/ClientInterface.md)
- [DSL to authorization model transformer](docs/API/Transformer.md)
- [Transformer interface](docs/API/TransformerInterface.md)
- [Internationalization messages](docs/API/Messages.md)

### Authentication

- [Base authentication interface](docs/API/Authentication/Authentication/AuthenticationInterface.md)
- [Pre-shared key authentication](docs/API/Authentication/Authentication/TokenAuthentication.md)
- [OAuth 2.0 client credentials](docs/API/Authentication/Authentication/ClientCredentialAuthentication.md)
- [OAuth access token management](docs/API/Authentication/Authentication/AccessToken.md)
- [Access token interface](docs/API/Authentication/Authentication/AccessTokenInterface.md)

### Models and Data Structures

- [Store model for data isolation](docs/API/Models/Models/Store.md)
- [Store interface](docs/API/Models/Models/StoreInterface.md)
- [Authorization model with type definitions](docs/API/Models/Models/AuthorizationModel.md)
- [Authorization model interface](docs/API/Models/Models/AuthorizationModelInterface.md)
- [Relationship tuple key (user, relation, object)](docs/API/Models/Models/TupleKey.md)
- [Tuple key interface](docs/API/Models/Models/TupleKeyInterface.md)
- [Complete relationship tuple with metadata](docs/API/Models/Models/Tuple.md)
- [Tuple interface](docs/API/Models/Models/TupleInterface.md)
- [Type definition with relations](docs/API/Models/Models/TypeDefinition.md)
- [Type definition interface](docs/API/Models/Models/TypeDefinitionInterface.md)
- [Conditional authorization logic](docs/API/Models/Models/Condition.md)
- [Condition interface](docs/API/Models/Models/ConditionInterface.md)

### Collections

- [Collection of tuple keys](docs/API/Models/Collections/Models/Collections/TupleKeys.md)
- [Tuple keys collection interface](docs/API/Models/Collections/Models/Collections/TupleKeysInterface.md)
- [Collection of tuples](docs/API/Models/Collections/Models/Collections/Tuples.md)
- [Tuples collection interface](docs/API/Models/Collections/Models/Collections/TuplesInterface.md)
- [Collection of type definitions](docs/API/Models/Collections/Models/Collections/TypeDefinitions.md)
- [Type definitions collection interface](docs/API/Models/Collections/Models/Collections/TypeDefinitionsInterface.md)
- [Batch check items collection](docs/API/Models/Collections/Models/Collections/BatchCheckItems.md)
- [Batch check items interface](docs/API/Models/Collections/Models/Collections/BatchCheckItemsInterface.md)
- [Collection of stores](docs/API/Models/Collections/Models/Collections/Stores.md)
- [Stores collection interface](docs/API/Models/Collections/Models/Collections/StoresInterface.md)

### Enumerations

- [Consistency levels for queries](docs/API/Models/Enums/Models/Enums/Consistency.md)
- [Authorization model schema versions](docs/API/Models/Enums/Models/Enums/SchemaVersion.md)
- [Tuple write operations (write/delete)](docs/API/Models/Enums/Models/Enums/TupleOperation.md)
- [Built-in type names](docs/API/Models/Enums/Models/Enums/TypeName.md)

### Requests and Responses

- [Authorization check request](docs/API/Requests/CheckRequest.md)
- [Check request interface](docs/API/Requests/CheckRequestInterface.md)
- [Batch authorization check request](docs/API/Requests/BatchCheckRequest.md)
- [Batch check request interface](docs/API/Requests/BatchCheckRequestInterface.md)
- [Write/delete tuples request](docs/API/Requests/WriteTuplesRequest.md)
- [Write tuples request interface](docs/API/Requests/WriteTuplesRequestInterface.md)
- [Read tuples request](docs/API/Requests/ReadTuplesRequest.md)
- [Read tuples request interface](docs/API/Requests/ReadTuplesRequestInterface.md)
- [Authorization check response](docs/API/Responses/CheckResponse.md)
- [Check response interface](docs/API/Responses/CheckResponseInterface.md)
- [Batch check response](docs/API/Responses/BatchCheckResponse.md)
- [Batch check response interface](docs/API/Responses/BatchCheckResponseInterface.md)

### Results and Error Handling

- [Success result wrapper](docs/API/Results/Results/Success.md)
- [Success interface](docs/API/Results/Results/SuccessInterface.md)
- [Failure result wrapper](docs/API/Results/Results/Failure.md)
- [Failure interface](docs/API/Results/Results/FailureInterface.md)
- [Base result interface](docs/API/Results/Results/ResultInterface.md)

### Exceptions

- [Base client exception](docs/API/Exceptions/Exceptions/ClientException.md)
- [Client throwable interface](docs/API/Exceptions/Exceptions/ClientThrowable.md)
- [Authentication errors](docs/API/Exceptions/Exceptions/AuthenticationException.md)
- [Configuration errors](docs/API/Exceptions/Exceptions/ConfigurationException.md)
- [Network and HTTP errors](docs/API/Exceptions/Exceptions/NetworkException.md)
- [Serialization errors](docs/API/Exceptions/Exceptions/SerializationException.md)

### Network and Infrastructure

- [HTTP request management](docs/API/Network/Network/RequestManager.md)
- [Request manager interface](docs/API/Network/Network/RequestManagerInterface.md)
- [Retry logic with exponential backoff](docs/API/Network/Network/RetryHandler.md)
- [Retry handler interface](docs/API/Network/Network/RetryHandlerInterface.md)
- [Circuit breaker for fault tolerance](docs/API/Network/Network/CircuitBreaker.md)
- [Circuit breaker interface](docs/API/Network/Network/CircuitBreakerInterface.md)
- [Request context and metadata](docs/API/Network/Network/RequestContext.md)
- [Request context interface](docs/API/Network/Network/RequestContextInterface.md)

### Observability and Monitoring

- [Telemetry provider interface](docs/API/Observability/Observability/TelemetryInterface.md)
- [OpenTelemetry integration](docs/API/Observability/Observability/OpenTelemetryProvider.md)
- [No-op telemetry provider](docs/API/Observability/Observability/NoOpTelemetryProvider.md)
- [Telemetry provider factory](docs/API/Observability/Observability/TelemetryFactory.md)

### Schema Validation

- [JSON schema definitions](docs/API/Schema/Schema/Schema.md)
- [Schema interface](docs/API/Schema/Schema/SchemaInterface.md)
- [Schema validation logic](docs/API/Schema/Schema/SchemaValidator.md)
- [Schema validator interface](docs/API/Schema/Schema/SchemaValidatorInterface.md)
- [Schema builder for dynamic schemas](docs/API/Schema/Schema/SchemaBuilder.md)
- [Schema builder interface](docs/API/Schema/Schema/SchemaBuilderInterface.md)

### Translation and Internationalization

- [Message translation service](docs/API/Translation/Translation/Translator.md)
- [Translator interface](docs/API/Translation/Translation/TranslatorInterface.md)
- [YAML parser for translation files](docs/API/Translation/Translation/YamlParser.md)

### Framework Integration

- [Laravel service provider](docs/API/Integration/Integration/ServiceProvider.md)

## Quick Reference for AI Assistants

### Common Usage Patterns

#### Basic Authorization Check
```php
use OpenFGA\Client;
use OpenFGA\Models\TupleKey;

$client = new Client(url: 'https://api.fga.example');

$result = $client->check(
    store: 'store_123',
    model: 'model_456',
    tupleKey: new TupleKey('user:alice', 'viewer', 'document:readme')
);

if ($result->success()) {
    $allowed = $result->value()->getAllowed();
}
```

#### Batch Authorization Checks
```php
use OpenFGA\Models\Collections\BatchCheckItems;
use OpenFGA\Models\BatchCheckItem;

$checks = new BatchCheckItems([
    new BatchCheckItem(
        tupleKey: new TupleKey('user:alice', 'viewer', 'document:budget'),
        correlationId: 'check-1'
    ),
    new BatchCheckItem(
        tupleKey: new TupleKey('user:bob', 'editor', 'document:budget'),
        correlationId: 'check-2'
    ),
]);

$result = $client->batchCheck(
    store: 'store_123',
    model: 'model_456',
    checks: $checks
);
```

#### DSL Authorization Model
```php
$dsl = '
    model
      schema 1.1

    type user

    type document
      relations
        define owner: [user]
        define editor: [user] or owner
        define viewer: [user] or editor
';

$model = $client->dsl($dsl)->unwrap();
```

#### Writing Relationship Tuples
```php
use OpenFGA\Models\Collections\TupleKeys;

$writes = new TupleKeys([
    new TupleKey('user:alice', 'owner', 'document:budget'),
    new TupleKey('user:bob', 'viewer', 'document:budget'),
]);

$result = $client->writeTuples(
    store: 'store_123',
    model: 'model_456',
    writes: $writes
);
```

#### List Objects a User Can Access
```php
$result = $client->listObjects(
    store: 'store_123',
    model: 'model_456',
    type: 'document',
    relation: 'viewer',
    user: 'user:alice'
);

if ($result->success()) {
    $documents = $result->value()->getObjects();
}
```

### Result Pattern Usage

The SDK uses the Result pattern instead of exceptions for expected failures:

```php
// Handle results with method chaining
$documents = $client->listObjects(...)
    ->success(fn($response) => echo "Found objects!")
    ->failure(fn($error) => echo "Error: " . $error->getMessage())
    ->unwrap(); // Gets value or throws exception

// Handle results with conditionals
$result = $client->check(...);
if ($result->success()) {
    $allowed = $result->value()->getAllowed();
} else {
    $error = $result->error();
    // Handle error
}
```

### Authentication Configuration

#### Pre-shared Key
```php
use OpenFGA\Authentication\TokenAuthentication;

$auth = new TokenAuthentication('your-api-key');
$client = new Client(
    url: 'https://api.fga.example',
    authentication: $auth
);
```

#### OAuth 2.0 Client Credentials
```php
use OpenFGA\Authentication\ClientCredentialAuthentication;

$auth = new ClientCredentialAuthentication(
    clientId: 'your-client-id',
    clientSecret: 'your-client-secret',
    tokenUrl: 'https://auth.fga.example/oauth/token'
);
$client = new Client(
    url: 'https://api.fga.example',
    authentication: $auth
);
```

### Common Commands

- **Install:** `composer require evansims/openfga-php`
- **Run Tests:** `composer test`
- **Generate API Docs:** `composer docs:api`
- **Generate LLMs.txt:** `composer docs:llms`
- **Lint Code:** `composer lint`

### Framework Integration

#### Laravel Service Provider
```php
// In config/app.php
'providers' => [
    OpenFGA\Integration\ServiceProvider::class,
],
```

The service provider registers the OpenFGA client in the container and provides configuration through Laravel's config system.

### Key Architecture Concepts

1. **Result Pattern:** All operations return Success/Failure objects instead of throwing exceptions
2. **Interface-First Design:** Every class implements an interface for testing and flexibility
3. **Type Safety:** Full PHP 8.3+ type hints throughout
4. **PSR Compliance:** Uses PSR-7/17/18 for HTTP handling
5. **Immutable Models:** All data models are immutable value objects
6. **Collection Types:** Type-safe collections for working with multiple objects
7. **Schema Validation:** Built-in JSON schema validation for all API interactions