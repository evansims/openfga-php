# OpenFGA PHP SDK - LLM Knowledge Base

This document contains comprehensive information about the OpenFGA PHP SDK for AI assistants and language models. It includes complete guides, API documentation references, and examples to help implement fine-grained authorization in PHP applications.

**Repository:** https://github.com/evansims/openfga-php  
**Documentation:** https://github.com/evansims/openfga-php/tree/main/docs  
**OpenFGA Documentation:** https://openfga.dev/docs  

## Key Information for AI Assistants

- **Language:** PHP 8.3+
- **Package Name:** `evansims/openfga-php`
- **Installation:** `composer require evansims/openfga-php`
- **Purpose:** Fine-grained authorization and relationship-based access control
- **Architecture:** Result pattern for error handling, PSR-7/17/18 HTTP standards
- **Testing:** `composer test` (unit, integration, contract tests)
- **Documentation Generation:** `composer docs:api`

## Complete Guides and Documentation


### SDK Overview and Quick Start

#### OpenFGA PHP SDK

Modern fine-grained authorization for PHP applications. Build permission systems that scale from simple role checks to complex multi-tenant authorization patterns.

##### What is this?

OpenFGA lets you answer questions like "Can Alice edit this document?" or "Which projects can Bob view?" without scattering permission logic throughout your codebase. Define your authorization rules once, then query them anywhere.

This SDK provides a modern PHP interface to [OpenFGA](https://openfga.dev) - Google's Zanzibar-inspired authorization engine that powers services like YouTube, Google Drive, and GitHub.

##### Quick start

```bash
composer require evansims/openfga-php
```

```php
use OpenFGA\Client;
use function OpenFGA\{allowed, tuple};

$client = new Client(url: 'https://api.fga.example');

// Check permissions - simple and clean
$canEdit = allowed(
    client: $client,
    store: 'store_123',
    model: 'model_456', 
    tuple: tuple('user:alice', 'editor', 'document:readme')
);

// Find accessible resources
$documents = $client->listObjects(
    store: 'store_123',
    model: 'model_456',
    user: 'user:alice',
    relation: 'viewer',
    type: 'document'
)->unwrap()->getObjects();
```

##### Why choose this SDK?

**Type-safe by design.** Every method has complete type hints. Your IDE knows exactly what you're working with.

**Error handling that makes sense.** No more try-catch blocks everywhere. The Result pattern lets you handle success and failure elegantly.

**Modern PHP patterns.** Built for PHP 8.3+ with property promotion, named arguments, and strict typing throughout.

**Production ready.** Comprehensive OpenTelemetry support, retry logic, circuit breakers, and graceful error handling.

##### Core concepts

###### Getting started → Introduction

New to OpenFGA? Start here to understand the basics and get your first authorization check working.

**[Getting Started Guide →](Introduction.md)**

###### Core concepts → Authorization models

Learn how to define your permission rules using OpenFGA's intuitive DSL.

**[Authorization Models →](Models.md)**

###### Core concepts → Relationship tuples

Understand how to grant and revoke specific permissions between users and resources.

**[Relationship Tuples →](Tuples.md)**

###### Querying → Permission checks

Master the four types of queries: check permissions, list objects, find users, and expand relationships.

**[Queries →](Queries.md)**

##### Configuration

###### Authentication → API credentials

Set up authentication for production environments and managed services.

**[Authentication →](Authentication.md)**

###### Configuration → Stores

Manage authorization stores for multi-tenant applications and environment separation.

**[Stores →](Stores.md)**

###### Configuration → Error handling

Build robust applications with proper error handling and the Result pattern.

**[Results →](Results.md)**

###### Observability → OpenTelemetry

Add comprehensive tracing and metrics to monitor your authorization system.

**[Observability →](Observability.md)**

##### Key features

**Modern PHP 8.3+** — Property promotion, named arguments, and strict typing
**Result pattern** — Elegant error handling without exceptions  
**PSR compliant** — Works with any PSR-7/17/18 HTTP implementation
**Type safe** — Complete type hints and IDE support
**DSL support** — Human-readable authorization model syntax
**Observability** — Built-in OpenTelemetry tracing and metrics
**Production ready** — Retry logic, circuit breakers, and graceful degradation

##### Need help?

**[OpenFGA Documentation](https://openfga.dev/docs)** — Learn authorization concepts and patterns
**[Report Issues](https://github.com/evansims/openfga-php/issues)** — Found a bug or need a feature?
**[API Reference](API/)** — Complete method documentation and examples


### Getting Started Guide

#### Getting started

Build your first authorization system in under 10 minutes. You'll install the SDK, connect to OpenFGA, and check your first permission.

##### What you'll learn

By the end of this guide, you'll have a working authorization system that can answer questions like "Can Alice view this document?" and understand the core concepts that power modern permission systems.

##### Prerequisites

You'll need PHP 8.3+ and Composer. The SDK handles HTTP communication through PSR interfaces, so you'll also need HTTP libraries:

```bash
#### If you don't have HTTP libraries yet
composer require guzzlehttp/guzzle guzzlehttp/psr7
```

##### Start an OpenFGA server

The easiest way is Docker - one command gets you running:

```bash
docker run -d -p 8080:8080 --name openfga openfga/openfga run
```

Your server is now accessible at `http://localhost:8080`.

**Using a managed service?** Skip this step and use your Auth0 FGA or hosted OpenFGA URL instead.

##### Install the SDK

```bash
composer require evansims/openfga-php
```

##### Create your first client

```php
use OpenFGA\Client;

$client = new Client(url: 'http://localhost:8080');
```

That's it. The client automatically discovers your HTTP libraries and handles all the low-level communication.

**For production:** You'll want authentication and better error handling. We'll cover that in [Authentication →](Authentication.md) and [Results →](Results.md).

##### How authorization works

Every authorization system needs three things:

**1. A store** — Think of this as a database for your permissions. Each application or tenant gets its own store.

**2. A model** — The rules that define what permissions exist. Like "documents can have viewers and editors."

**3. Relationships** — Specific permissions between users and resources. Like "Alice can view document:readme."

Once you have these, you can ask questions like "Can Alice edit this document?" and get instant answers.

##### Build your first authorization system

Here's a complete working example that sets up authorization for a document system:

```php
use OpenFGA\Client;
use function OpenFGA\{store, dsl, model, tuple, tuples, write, allowed};

$client = new Client(url: 'http://localhost:8080');

// 1. Create a store for your app
$storeId = store($client, 'document-system');
echo "Created store: {$storeId}\n";

// 2. Define what permissions exist
$dsl = <<<DSL
model
  schema 1.1

type user

type document
  relations
    define viewer: [user]
    define editor: [user] 
DSL;

$model = dsl($client, $dsl);
$modelId = model($client, $storeId, $model);
echo "Created model: {$modelId}\n";

// 3. Grant Alice permission to view the readme
write(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('user:alice', 'viewer', 'document:readme')
);
echo "Granted alice viewer permission on readme\n";

// 4. Check if Alice can view the document
$canView = allowed(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuple: tuple('user:alice', 'viewer', 'document:readme')
);

echo $canView ? "✅ Alice can view readme" : "❌ Access denied";
```

**Run this example:**

1. Make sure your OpenFGA server is running
2. Save the code as `example.php` 
3. Run `php example.php`

You should see confirmation messages and a final "Alice can view readme" success message.

##### What's next?

Now that you have a working authorization system, here's how to level up:

###### Core concepts → Authorization models
Learn to build complex permission systems with inheritance, conditions, and multi-tenant patterns.
**[Authorization Models →](Models.md)**

###### Querying → Permission checks  
Master the four query types: check permissions, list accessible objects, find users, and expand relationships.
**[Queries →](Queries.md)**

###### Configuration → Error handling
Build production-ready apps with proper error handling using the Result pattern.
**[Results →](Results.md)**

###### Authentication → Production setup
Secure your OpenFGA connection with API keys and client credentials.
**[Authentication →](Authentication.md)**

**Building something complex?** Check out [Relationship Tuples →](Tuples.md) for managing permissions at scale, or [Observability →](Observability.md) for observability.


### Authentication and Configuration

#### Authentication

Most OpenFGA servers require authentication, especially in production. Here's how to authenticate your PHP SDK client.

##### When do you need authentication?

- **Production environments** - Always required
- **Auth0 FGA** - Always required
- **Local development** - Usually optional

##### Production Setup

###### Client Credentials (Recommended)

This is the most common authentication method for production applications. The SDK handles OAuth token management automatically.

```php
use OpenFGA\Client;
use OpenFGA\Authentication\ClientCredentialAuthentication;

$client = new Client(
    url: $_ENV['FGA_API_URL'],
    authentication: new ClientCredentialAuthentication(
        clientId: $_ENV['FGA_CLIENT_ID'],
        clientSecret: $_ENV['FGA_CLIENT_SECRET'],
        issuer: $_ENV['FGA_ISSUER'],
        audience: $_ENV['FGA_AUDIENCE'],
    ),
);
```

**Environment variables:**
```bash
FGA_API_URL=https://api.us1.fga.dev
FGA_CLIENT_ID=your_client_id
FGA_CLIENT_SECRET=your_client_secret
FGA_ISSUER=https://your-tenant.us.auth0.com/oauth/token
FGA_AUDIENCE=https://api.us1.fga.dev/
```

###### API Token

For simpler setups or self-hosted OpenFGA instances that support API tokens:

```php
use OpenFGA\Client;
use OpenFGA\Authentication\TokenAuthentication;

$client = new Client(
    url: $_ENV['FGA_API_URL'],
    authentication: new TokenAuthentication($_ENV['FGA_API_TOKEN']),
);
```

**Environment variables:**
```bash
FGA_API_URL=https://your-openfga-server.com
FGA_API_TOKEN=your_api_token
```

##### Development Setup

For local development against a Docker container or development server:

```php
use OpenFGA\Client;
use OpenFGA\Authentication\NoAuthentication;

$client = new Client(
    url: $_ENV['FGA_API_URL'] ?? 'http://localhost:8080',
    authentication: new NoAuthentication(),
);
```

##### Client Configuration Patterns

###### Using a factory method

```php
final readonly class FgaClientFactory
{
    public static function create(): Client
    {
        return match ($_ENV['APP_ENV'] ?? 'production') {
            'development', 'testing' => new Client(
                url: $_ENV['FGA_API_URL'] ?? 'http://localhost:8080',
                authentication: new NoAuthentication(),
            ),
            default => new Client(
                url: $_ENV['FGA_API_URL'],
                authentication: new ClientCredentialAuthentication(
                    clientId: $_ENV['FGA_CLIENT_ID'],
                    clientSecret: $_ENV['FGA_CLIENT_SECRET'],
                    issuer: $_ENV['FGA_ISSUER'],
                    audience: $_ENV['FGA_AUDIENCE'],
                ),
            ),
        };
    }
}
```

###### Dependency injection

```php
// In your service container
$container->singleton(ClientInterface::class, function () {
    return new Client(
        url: config('fga.url'),
        authentication: new ClientCredentialAuthentication(
            clientId: config('fga.client_id'),
            clientSecret: config('fga.client_secret'),
            issuer: config('fga.issuer'),
            audience: config('fga.audience'),
        ),
    );
});
```

##### Troubleshooting

###### Authentication failed

- Verify your environment variables are set correctly
- Check that your client ID and secret are valid
- Ensure the issuer URL includes the full path (e.g., `/oauth/token`)

###### Token expired errors

The SDK automatically refreshes tokens for Client Credentials authentication. If you're seeing expired token errors:

- Check your system clock is accurate
- Verify the audience URL matches your OpenFGA API endpoint exactly

###### Local development issues

If authentication isn't working locally:

- Confirm your OpenFGA server allows unauthenticated requests
- Try using `NoAuthentication()` explicitly
- Check the server logs for authentication requirements

###### Environment variable loading

Use a package like `vlucas/phpdotenv` for development:

```php
// Load .env file in development
if (file_exists(__DIR__ . '/.env')) {
    $dotenv = Dotenv\Dotenv::createImmutable(__DIR__);
    $dotenv->load();
}
```


### Store Management

#### Stores

Think of a store as your authorization workspace. It contains your permission rules, user relationships, and everything needed to answer "can this user do that?" Each store is completely isolated - perfect for separating environments, tenants, or applications.

Every OpenFGA operation happens within a store, making them the foundation of your authorization system.

##### What are stores?

A store holds three things:
- **Authorization models** - your permission rules
- **Relationship tuples** - who can do what 
- **Assertions** - tests to verify everything works

Most apps start with one store and add more as they grow.

##### Single application setup

For a typical application, create one store per environment:

```php
use OpenFGA\Client;
use function OpenFGA\store;

$client = new Client(url: $_ENV['FGA_API_URL']);

// Create your production store
$storeId = store($client, 'myapp-production'); // Save this!

// Configure your client to use this store
$client = $client->withStore(store: $storeId);
```

Store that ID in your environment configuration - you'll need it for every API call.

##### Multi-tenant patterns

For SaaS applications, create a store per customer to ensure complete data isolation:

```php
final readonly class TenantStoreManager
{
    public function __construct(private Client $client) {}
    
    public function createTenantStore(string $customerId): string
    {
        $store = $this->client
            ->createStore(name: "customer-{$customerId}")
            ->unwrap();
            
        return $store->getId();
    }
    
    public function getClientForTenant(string $customerId): Client
    {
        $storeId = $this->lookupStoreId($customerId);
        return $this->client->withStore(store: $storeId);
    }
}

// Usage
$manager = new TenantStoreManager($client);
$storeId = $manager->createTenantStore('acme-corp');
```

##### Environment separation

Keep your environments completely isolated:

```php
enum Environment: string
{
    case Development = 'dev';
    case Staging = 'staging'; 
    case Production = 'prod';
}

function createEnvironmentStore(Environment $env, string $appName): string
{
    $client = new Client(url: $_ENV['FGA_API_URL']);
    $store = $client->createStore(name: "{$appName}-{$env->value}")->unwrap();
    
    return $store->getId();
}

// Create stores for each environment
$devStoreId = createEnvironmentStore(Environment::Development, 'myapp');
$prodStoreId = createEnvironmentStore(Environment::Production, 'myapp');
```

##### Store management

Finding and managing existing stores:

```php
// List all stores
$stores = $client->listStores(pageSize: 20)->unwrap();
foreach ($stores->getStores() as $store) {
    echo "{$store->getName()}: {$store->getId()}\n";
}

// Get specific store details
$store = $client->getStore(store: $storeId)->unwrap();
echo "Created: {$store->getCreatedAt()->format('Y-m-d H:i:s')}\n";

// Delete a store (careful - this is permanent!)
$client->deleteStore(store: $oldStoreId)->unwrap();
```

For pagination with many stores:

```php
$continuationToken = null;
do {
    $response = $client->listStores(
        pageSize: 10,
        continuationToken: $continuationToken
    )->unwrap();
    
    foreach ($response->getStores() as $store) {
        // Process each store
    }
    
    $continuationToken = $response->getContinuationToken();
} while ($continuationToken !== null);
```

##### Best practices

**When to use multiple stores:**
- Different environments (dev/staging/production)
- Different customers in SaaS apps
- Different applications with no shared permissions
- Compliance requirements for data isolation

**When to use a single store:**
- Different user roles (use authorization models instead)
- Different features in the same app (use object types)
- A/B testing (use different object IDs)

**Naming conventions:**
```php
// Good names
'myapp-production'
'customer-acme-corp'  
'billing-service-staging'

// Avoid
'store1'
'test'
'temp'
```

**Pro tips:**
- Start with one store per environment
- Save store IDs in your configuration
- Test your app works with store switching
- Document which team owns each store

##### Next steps

With your store ready, create an [Authorization Model](Models.md) to define your permission rules.


### Authorization Models and DSL

#### Authorization Models

Authorization models are your permission blueprint. They define what types of things exist in your system and how they relate to each other. Think database schema, but for permissions.

##### Building your first model

Let's jump right into building a document sharing system. Here's what we want:

- Users can own, edit, or view documents
- Owners can do everything
- Editors can edit and view
- Viewers can only view

```fsharp
model
  schema 1.1

type user

type document
  relations
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor
```

That's it. The `or` keyword creates inheritance - owners automatically become editors, and editors automatically become viewers.

##### Creating your model

Transform your DSL into a model object and create it on the server:

```php
use OpenFGA\Client;

$client = new Client(url: 'http://localhost:8080');

$dsl = <<<DSL
model
  schema 1.1

type user

type document
  relations
    define owner: [user]
    define editor: [user] or owner
    define viewer: [user] or editor
DSL;

// Transform DSL to model object
$model = $client->dsl($dsl)->unwrap();

// Create on server
$response = $client->createAuthorizationModel(
    store: $storeId,
    typeDefinitions: $model->getTypeDefinitions(),
    conditions: $model->getConditions()
)->unwrap();

$modelId = $response->getId();
```

Save that `$modelId` - you'll need it for everything else.

##### Common patterns

###### Direct assignment

The simplest relationship - a user directly has a role:

```fsharp
type document
  relations
    define owner: [user]
```

This lets you write tuples like `user:alice owner document:readme`.

###### Computed relations

Relations that inherit from other relations:

```fsharp
type document
  relations
    define owner: [user]
    define editor: owner  // All owners are editors
    define viewer: editor // All editors are viewers
```

###### Union relations

Multiple ways to get the same permission:

```fsharp
type document
  relations
    define owner: [user]
    define editor: [user] or owner     // Direct editors OR owners
    define viewer: [user] or editor    // Direct viewers OR editors
```

###### Hierarchical permissions

Inherit permissions from parent objects:

```fsharp
type folder
  relations
    define owner: [user]
    define viewer: [user] or owner

type document
  relations
    define parent: [folder]
    define owner: [user]
    define viewer: [user] or owner or viewer from parent
```

Now documents inherit viewer permissions from their parent folder.

###### Group membership

Users belong to groups, groups have permissions:

```fsharp
type user

type group
  relations
    define member: [user]

type document
  relations
    define owner: [user, group#member]
    define viewer: [user, group#member] or owner
```

The `group#member` syntax means "users who are members of the group".

##### Working with conditions

Add context-aware permissions using conditions:

```fsharp
type document
  relations
    define viewer: [user with valid_ip]
    define editor: [user with business_hours]
```

Define conditions when creating your model:

```php
use OpenFGA\Models\{Condition, ConditionMetadata, ConditionParameter};
use OpenFGA\Models\Collections\{Conditions, ConditionParameters};

$conditions = new Conditions([
    new Condition(
        name: 'valid_ip',
        expression: 'ip_address in allowed_ips',
        parameters: new ConditionParameters([
            new ConditionParameter(
                name: 'allowed_ips',
                typeName: 'list'
            )
        ])
    )
]);

$response = $client->createAuthorizationModel(
    store: $storeId,
    typeDefinitions: $model->getTypeDefinitions(),
    conditions: $conditions
)->unwrap();
```

##### Using models in your application

###### Set the active model

```php
$client->setModel($modelId);
```

###### Check permissions

```php
$canView = $client->check(
    user: 'user:alice',
    relation: 'viewer',
    object: 'document:readme'
)->unwrap()->getAllowed();
```

###### List user's objects

```php
$documents = $client->listObjects(
    user: 'user:alice',
    relation: 'viewer',
    type: 'document'
)->unwrap()->getObjects();
```

##### Advanced patterns

###### Multi-tenant systems

Each tenant has their own workspace:

```fsharp
type user

type tenant
  relations
    define member: [user]
    define admin: [user]

type document
  relations
    define tenant: [tenant]
    define owner: [user] and member from tenant
    define viewer: [user] and member from tenant
```

The `and` keyword requires both conditions - users must be both assigned the role AND be members of the tenant.

###### Approval workflows

Documents need approval before publishing:

```fsharp
type document
  relations
    define owner: [user]
    define editor: [user] or owner
    define approver: [user]
    define can_publish: approver and owner
    define viewer: [user] or can_publish
```

###### Time-based access

```fsharp
type document
  relations
    define owner: [user]
    define viewer: [user with during_work_hours] or owner
```

###### Nested resources

Permissions flow down through resource hierarchies:

```fsharp
type organization
  relations
    define admin: [user]
    define member: [user] or admin

type project
  relations
    define organization: [organization]
    define admin: [user] or admin from organization
    define member: [user] or member from organization

type document
  relations
    define project: [project]
    define editor: [user] or admin from project
    define viewer: [user] or member from project
```

##### Managing models

###### List all models

```php
$models = $client->listAuthorizationModels(
    store: $storeId,
    pageSize: 10
)->unwrap()->getModels();

foreach ($models as $model) {
    echo "Model ID: " . $model->getId() . "\n";
}
```

###### Get a specific model

```php
$model = $client->getAuthorizationModel(
    store: $storeId,
    model: $modelId
)->unwrap()->getModel();

// Convert back to DSL
echo $model->dsl();
```

###### Version your models

Always create new models instead of modifying existing ones. Keep the old model ID for backward compatibility:

```php
// Deploy new model
$newModelId = $client->createAuthorizationModel(/*...*/)
    ->unwrap()->getId();

// Gradually migrate tuples to new model
// Switch applications to use $newModelId
```

##### What's next

Now that you have a model:

1. **[Write relationship tuples](Tuples.md)** - Connect users to objects
2. **[Perform queries](Queries.md)** - Check permissions and list objects  
3. **[Test with assertions](Assertions.md)** - Verify your model works correctly

Your authorization model is the foundation everything else builds on. Take time to design it well.

### Relationship Tuples

#### Relationship Tuples

Relationship tuples are where the rubber meets the road. They're the actual permissions in your system - who can do what to which resource.

A tuple is simply: `(user, relation, object)`

For example: `(user:anne, editor, document:roadmap)` means "Anne can edit the roadmap document."

```php
<?php

use OpenFGA\Client;
use function OpenFGA\{tuple, tuples, write, delete};

// Basic setup - see Getting Started for full client initialization
$client = new Client(url: 'http://localhost:8080');
```

##### Granting Permissions

Give someone access by writing a tuple:

```php
// Give Anne editor access to a document
write(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('user:anne', 'editor', 'document:roadmap')
);
```

##### Removing Permissions  

Take away access by deleting a tuple:

```php
// Remove Anne's editor access
delete(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('user:anne', 'editor', 'document:roadmap')
);
```

##### Bulk Operations

Handle multiple permission changes in one transaction:

```php
// Grant access to multiple users and revoke old permissions
$client->writeTuples(
    store: $storeId,
    model: $modelId,
    writes: tuples(
        tuple('user:bob', 'viewer', 'document:roadmap'),
        tuple('user:charlie', 'editor', 'document:roadmap'),
        tuple('team:marketing#member', 'viewer', 'folder:campaigns')
    ),
    deletes: tuples(
        tuple('user:anne', 'owner', 'document:old-spec')
    )
)->unwrap();
```
##### Reading Existing Permissions

Check what permissions exist by reading tuples:

```php
use OpenFGA\Models\TupleKey;

// Find all permissions for a specific document
$response = $client->readTuples(
    store: $storeId,
    model: $modelId,
    tupleKey: new TupleKey(object: 'document:roadmap')
)->unwrap();

foreach ($response->getTuples() as $tuple) {
    echo "{$tuple->getUser()} has {$tuple->getRelation()} on {$tuple->getObject()}\n";
}
```

```php
// Find all documents Anne can edit
$response = $client->readTuples(
    store: $storeId,
    model: $modelId,
    tupleKey: new TupleKey(user: 'user:anne', relation: 'editor')
)->unwrap();

foreach ($response->getTuples() as $tuple) {
    echo "Anne can edit: {$tuple->getObject()}\n";
}
```

```php
// Paginate through all tuples
$continuationToken = null;

do {
    $response = $client->readTuples(
        store: $storeId,
        model: $modelId,
        pageSize: 100,
        continuationToken: $continuationToken
    )->unwrap();
    
    foreach ($response->getTuples() as $tuple) {
        // Process each tuple...
    }
    
    $continuationToken = $response->getContinuationToken();
} while ($continuationToken !== null);
```

##### Advanced Patterns

###### Conditional Tuples

Add conditions to make permissions context-dependent:

```php
use OpenFGA\Models\{ConditionParameter, ConditionParameters, RelationshipCondition, TupleKey, TupleKeys};

// Only allow access during business hours
$client->writeTuples(
    store: $storeId,
    model: $modelId,
    writes: new TupleKeys([
        new TupleKey(
            user: 'user:contractor',
            relation: 'viewer',
            object: 'document:sensitive',
            condition: new RelationshipCondition(
                name: 'business_hours',
                context: [
                    'timezone' => 'America/New_York'
                ]
            )
        )
    ])
)->unwrap();
```

###### Tracking Changes

Monitor permission changes over time for auditing:

```php
// Get all permission changes for documents in the last hour
$startTime = (new DateTimeImmutable())->sub(new DateInterval('PT1H'));

$response = $client->listTupleChanges(
    store: $storeId,
    model: $modelId,
    type: 'document',
    startTime: $startTime
)->unwrap();

foreach ($response->getChanges() as $change) {
    $tuple = $change->getTupleKey();
    echo "{$change->getOperation()->value}: {$tuple->getUser()} {$tuple->getRelation()} {$tuple->getObject()}\n";
}
```

###### Working with Groups

Grant permissions to groups instead of individual users:

```php
// Add user to a group
write(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('user:anne', 'member', 'team:engineering')
);

// Grant permission to the entire group
write(
    client: $client,
    store: $storeId,
    model: $modelId,
    tuples: tuple('team:engineering#member', 'editor', 'document:technical-specs')
);
```

Now Anne can edit the technical specs because she's a member of the engineering team.

For checking permissions and querying relationships, see [Queries](Queries.md).


### Authorization Queries and Checks

#### Queries

Ready to check permissions? Once you've set up your [authorization model](Models.md) and [relationship tuples](Tuples.md), it's time to actually use them. This is where OpenFGA shines - answering permission questions in real-time.

##### What are queries?

Queries let you ask OpenFGA about permissions. There are four types:

- **Check permissions** - "Can Alice edit this document?"
- **List accessible objects** - "What documents can Alice edit?"
- **Find users with permission** - "Who can edit this document?"
- **Expand relationships** - "How does Alice have edit access?" (for debugging)

##### Check permissions

This is the most common query. Use it to enforce access control in your app.

```php
use OpenFGA\Models\TupleKey;
use function OpenFGA\tuple;

// Can user:alice view document:roadmap?
$result = $client->check(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'viewer',
        object: 'document:roadmap'
    )
);

if ($result->unwrap()->getAllowed()) {
    // Alice can view the document
    echo "Access granted";
} else {
    // Alice cannot view the document
    echo "Access denied";
}
```

###### Real-world usage

```php
use function OpenFGA\{allowed, tuple};

function canUserEdit(ClientInterface $client, string $storeId, string $modelId, string $userId, string $documentId): bool 
{
    return allowed(
        client: $client,
        store: $storeId,
        model: $modelId,
        tuple: tuple("user:{$userId}", 'editor', "document:{$documentId}")
    );
}

// In your controller
if (!canUserEdit($client, $storeId, $modelId, $currentUserId, $documentId)) {
    throw new ForbiddenException('You cannot edit this document');
}
```

##### List accessible objects

Perfect for building dashboards and filtered lists. Shows what a user can access.

```php
// What documents can alice edit?
$result = $client->listObjects(
    user: 'user:alice',
    relation: 'editor',
    type: 'document'
);

$documentIds = $result->unwrap()->getObjects();
// Returns: ['roadmap', 'budget', 'proposal']
```

###### Building a document list

```php
function getEditableDocuments(string $userId): array 
{
    $result = $client->listObjects(
        user: "user:{$userId}",
        relation: 'editor',
        type: 'document'
    );
    
    $documentIds = $result->unwrap()->getObjects();
    
    // Fetch full document details from your database
    return Document::whereIn('id', $documentIds)->get();
}
```

##### Find users with permission

Great for admin interfaces and sharing features. Shows who has access to something.

```php
// Who can edit document:roadmap?
$result = $client->listUsers(
    object: 'document:roadmap',
    relation: 'editor'
);

$users = $result->unwrap()->getUsers();

foreach ($users as $user) {
    if ($user->isUser()) {
        echo "User: " . $user->getUserId() . "\n";
    } elseif ($user->isUserset()) {
        echo "Group: " . $user->getUsersetObject() . "\n";
    }
}
```

###### Building a sharing interface

```php
function getDocumentEditors(string $documentId): array 
{
    $result = $client->listUsers(
        object: "document:{$documentId}",
        relation: 'editor'
    );
    
    $editors = [];
    foreach ($result->unwrap()->getUsers() as $user) {
        if ($user->isUser()) {
            $editors[] = [
                'type' => 'user',
                'id' => $user->getUserId(),
                'name' => User::find($user->getUserId())->name
            ];
        }
    }
    
    return $editors;
}
```

##### Expand relationships (debugging)

When permissions aren't working as expected, use expand to see why. It shows the complete relationship tree.

```php
use OpenFGA\Models\TupleKey;

// How can anyone be a viewer of document:roadmap?
$result = $client->expand(
    tupleKey: new TupleKey(
        relation: 'viewer',
        object: 'document:roadmap'
        // Note: no user specified for expand
    )
);

$tree = $result->unwrap()->getTree();
print_r($tree->toArray()); // Shows the complete permission tree
```

This is mainly useful for debugging complex permission structures or understanding why a user has (or doesn't have) access.

##### Advanced patterns

###### Contextual tuples

Test "what-if" scenarios without permanently saving relationships. Perfect for previewing permission changes.

```php
use function OpenFGA\{tuple, tuples};

// What if alice joins the engineering team?
$contextualTuple = tuple(
    user: 'user:alice',
    relation: 'member', 
    object: 'team:engineering'
);

$result = $client->check(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'viewer',
        object: 'document:technical-specs'
    ),
    contextualTuples: tuples($contextualTuple)
);

// This check includes the temporary relationship
$wouldHaveAccess = $result->unwrap()->getIsAllowed();
```

###### Consistency levels

For read-after-write scenarios, you might need stronger consistency:

```php
use OpenFGA\Models\Enums\Consistency;

$result = $client->check(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'viewer',
        object: 'document:roadmap'
    ),
    consistency: Consistency::HIGHER_CONSISTENCY
);
```

###### Error handling

All query methods return Result objects. Handle errors gracefully:

```php
$result = $client->check(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'viewer', 
        object: 'document:roadmap'
    )
);

$result
    ->success(fn($response) => echo "Check succeeded")
    ->failure(fn($error) => logger()->error("Permission check failed", ['error' => $error]))
    ->unwrap(); // Throws on failure
```

##### What's next?

Now that you can query permissions, you might want to:

- [Write assertions](Assertions.md) to test your permission logic
- Learn about [error handling](Results.md) for production apps
- Explore [authorization models](Models.md) for complex scenarios


### Testing with Assertions

#### Testing Your Authorization Model

Think of assertions as unit tests for your permission system. They let you define what should and shouldn't be allowed, then verify your authorization model works correctly before deploying it to production.

##### What are assertions?

Assertions are test cases that specify expected outcomes for permission checks. Each assertion says "user X should (or shouldn't) have permission Y on resource Z" and verifies this against your authorization model.

```php
use OpenFGA\Client;
use function OpenFGA\{tuple, tuples};
use OpenFGA\Models\Assertion;
use OpenFGA\Collections\Assertions;

$client = new Client(url: $_ENV['FGA_API_URL']);
```

##### Writing your first test

Let's say you're building a document management system. You want to test that owners can edit documents but viewers cannot:

```php
// Test: Document owners can edit
$ownerCanEdit = new Assertion(
    tupleKey: tuple(
        user: 'user:alice',
        relation: 'can_edit',
        object: 'document:quarterly-report'
    ),
    expectation: true
);

// Test: Viewers cannot edit
$viewerCannotEdit = new Assertion(
    tupleKey: tuple(
        user: 'user:bob',
        relation: 'can_edit', 
        object: 'document:quarterly-report'
    ),
    expectation: false
);

$tests = new Assertions([$ownerCanEdit, $viewerCannotEdit]);

$client->writeAssertions(
    store: $storeId,
    model: $modelId,
    assertions: $tests
)->unwrap();
```

##### Testing permission inheritance

Complex authorization models often have inherited permissions. Test these relationships to ensure they work as expected:

```php
// In a team workspace, team members inherit folder permissions
$teamFolderAccess = [
    // Direct team member access
    new Assertion(
        tupleKey: tuple('user:sarah', 'can_read', 'folder:team-docs'),
        expectation: true
    ),
    
    // Inherited document access through folder membership
    new Assertion(
        tupleKey: tuple('user:sarah', 'can_read', 'document:team-meeting-notes'),
        expectation: true
    ),
    
    // Non-team members should be denied
    new Assertion(
        tupleKey: tuple('user:outsider', 'can_read', 'folder:team-docs'),
        expectation: false
    ),
];
```

##### Testing edge cases

Test boundary conditions and special cases in your permission model:

```php
$edgeCases = [
    // Public documents should be readable by anyone
    new Assertion(
        tupleKey: tuple('user:*', 'can_read', 'document:company-handbook'),
        expectation: true
    ),
    
    // Deleted users should lose all access
    new Assertion(
        tupleKey: tuple('user:former-employee', 'can_read', 'document:confidential'),
        expectation: false
    ),
    
    // Admin override permissions
    new Assertion(
        tupleKey: tuple('user:admin', 'can_delete', 'document:any-document'),
        expectation: true
    ),
    
    // Cross-organization access should be blocked
    new Assertion(
        tupleKey: tuple('user:competitor', 'can_read', 'document:internal-strategy'),
        expectation: false
    ),
];
```

##### Managing test data

Organize your assertions logically and keep them maintainable:

```php
class DocumentPermissionTests
{
    public static function getBasicPermissions(): array
    {
        return [
            // Owner permissions
            new Assertion(tuple('user:owner', 'can_read', 'document:doc1'), true),
            new Assertion(tuple('user:owner', 'can_edit', 'document:doc1'), true),
            new Assertion(tuple('user:owner', 'can_delete', 'document:doc1'), true),
            
            // Editor permissions  
            new Assertion(tuple('user:editor', 'can_read', 'document:doc1'), true),
            new Assertion(tuple('user:editor', 'can_edit', 'document:doc1'), true),
            new Assertion(tuple('user:editor', 'can_delete', 'document:doc1'), false),
            
            // Viewer permissions
            new Assertion(tuple('user:viewer', 'can_read', 'document:doc1'), true),
            new Assertion(tuple('user:viewer', 'can_edit', 'document:doc1'), false),
            new Assertion(tuple('user:viewer', 'can_delete', 'document:doc1'), false),
        ];
    }
    
    public static function getInheritanceTests(): array
    {
        return [
            // Team lead inherits team permissions
            new Assertion(tuple('user:team-lead', 'can_manage', 'team:engineering'), true),
            new Assertion(tuple('user:team-lead', 'can_read', 'document:team-roadmap'), true),
        ];
    }
}

// Write different test suites
$client->writeAssertions(
    store: $storeId,
    model: $modelId,
    assertions: new Assertions([
        ...DocumentPermissionTests::getBasicPermissions(),
        ...DocumentPermissionTests::getInheritanceTests(),
    ])
)->unwrap();
```

##### Best practices

**Start with critical paths**: Test the most important permission checks first - admin access, user data privacy, billing permissions.

**Test both positive and negative cases**: Don't just test what should work, test what should be blocked.

**Use realistic data**: Test with actual user IDs, resource names, and permission types from your application.

**Update tests when models change**: Assertions should evolve with your authorization model. Treat them like any other test suite.

**Validate before deployment**: Run assertions in your CI/CD pipeline to catch permission regressions before they reach production.

```php
// Reading existing assertions for review
$response = $client->readAssertions(store: $storeId, model: $modelId)->unwrap();

foreach ($response->getAssertions() as $assertion) {
    $key = $assertion->getTupleKey();
    $expected = $assertion->getExpectation() ? 'CAN' : 'CANNOT';
    
    echo "{$key->getUser()} {$expected} {$key->getRelation()} {$key->getObject()}\n";
}
```

Remember: assertions replace all existing tests for a model when you call `writeAssertions()`. Always include your complete test suite in each call.


### Result Pattern and Error Handling

#### Results

##### Why use Results?

Tired of wrapping every API call in try-catch blocks? The OpenFGA SDK uses Results to make error handling explicit and chainable:

```php
// Instead of this mess:
try {
    $store = $client->getStore($storeId);
    try {
        $model = $client->getAuthorizationModel($store->getId(), $modelId);
        // Do something with $model
    } catch (Exception $e) {
        // Handle model error
    }
} catch (Exception $e) {
    // Handle store error
}

// You get this:
$client->getStore($storeId)
    ->then(fn($store) => $client->getAuthorizationModel($store->getId(), $modelId))
    ->success(fn($model) => $this->processModel($model))
    ->failure(fn($error) => $this->logError($error));
```

All SDK methods return either `Success` or `Failure` objects instead of throwing exceptions for expected failures like "not found" or validation errors.

##### Basic usage

The most common patterns you'll need:

###### Just get the value

```php
// Get the value or throw on failure
$store = $client->getStore($storeId)->unwrap();

// Get the value with a fallback
$store = $client->getStore($storeId)->unwrap(
    fn($error) => Store::default()
);
```

###### Handle success and failure

```php
$result = $client->createStore(name: 'my-store');

$result
    ->success(fn($store) => logger()->info("Created store: {$store->getId()}"))
    ->failure(fn($error) => logger()->error("Failed: {$error->getMessage()}"));
```

###### Check the outcome

```php
if ($result->succeeded()) {
    $store = $result->unwrap();
    // Do something with $store
}

if ($result->failed()) {
    $error = $result->err();
    // Handle the error
}
```

##### Chaining operations

Results really shine when you need to chain multiple operations:

###### Transform success values with `then()`

```php
$result = $client->getStore($storeId)
    ->then(fn($store) => $client->getAuthorizationModel($store->getId(), $modelId))
    ->then(fn($model) => $this->processModel($model));
```

###### Provide fallbacks with `recover()`

```php
$config = $client->getStore($storeId)
    ->then(fn($store) => $store->getConfiguration())
    ->recover(fn($error) => Configuration::default())
    ->unwrap();
```

###### Pipeline with side effects

```php
$client->writeTuples($store, $model, $tuples)
    ->success(fn($response) => $this->logSuccess($response))
    ->failure(fn($error) => $this->logError($error))
    ->then(fn($response) => $this->notifyWebhooks($response))
    ->recover(fn($error) => $this->handleFailure($error));
```

##### Error handling patterns

###### Fail gracefully

```php
// Return a sensible default when things go wrong
function getUserPermissions(string $userId): array 
{
    return $client->listObjects(user: $userId, relation: 'can_access')
        ->then(fn($response) => $response->getObjects())
        ->recover(fn($error) => []) // Empty permissions on error
        ->unwrap();
}
```

###### Collect multiple results

```php
$permissions = collect(['read', 'write', 'delete'])
    ->map(fn($action) => $client->check(user: $userId, relation: $action, object: $resourceId))
    ->filter(fn($result) => $result->succeeded())
    ->map(fn($result) => $result->unwrap()->getIsAllowed())
    ->toArray();
```

###### Add context to errors

```php
$result = $client->writeTuples($store, $model, $tuples)
    ->failure(function(Throwable $e) use ($store) {
        logger()->error("Failed to write tuples to store {$store->getId()}", [
            'error' => $e->getMessage(),
            'tuples_count' => count($tuples)
        ]);
    });
```

###### Convert errors to application exceptions

```php
$model = $client->getAuthorizationModel($storeId, $modelId)
    ->recover(fn($error) => throw new ModelNotFoundException($modelId, previous: $error))
    ->unwrap();
```

##### Advanced patterns

###### Retry with exponential backoff

```php
function checkWithRetry(string $user, string $relation, string $object): bool 
{
    return retry(3, function() use ($user, $relation, $object) {
        return $this->client->check(
            user: $user, 
            relation: $relation, 
            object: $object
        )->unwrap()->getIsAllowed();
    }, sleepMilliseconds: fn($attempt) => $attempt * 1000);
}
```

###### Batch operations with partial failures

```php
function batchCheck(array $checks): array 
{
    return collect($checks)
        ->map(fn($check) => $this->client->check(...$check))
        ->map(fn($result, $index) => [
            'index' => $index,
            'allowed' => $result->succeeded() && $result->unwrap()->getIsAllowed(),
            'error' => $result->failed() ? $result->err()->getMessage() : null
        ])
        ->toArray();
}
```

###### Framework integration

###### Laravel Service

```php
class PermissionService
{
    public function __construct(
        private ClientInterface $client,
        private string $storeId,
        private string $modelId
    ) {}

    public function can(string $user, string $action, string $resource): bool
    {
        return $this->client
            ->check(
                store: $this->storeId, 
                model: $this->modelId, 
                tupleKey: tuple($user, $action, $resource)
            )
            ->then(fn($response) => $response->getIsAllowed())
            ->recover(function(Throwable $e) {
                Log::warning('Permission check failed', [
                    'user' => $user,
                    'action' => $action, 
                    'resource' => $resource,
                    'error' => $e->getMessage()
                ]);
                return false; // Fail closed
            })
            ->unwrap();
    }
}
```

###### Symfony Voter

```php
class FgaVoter extends Voter
{
    protected function voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token): bool
    {
        return $this->client
            ->check(
                store: $this->store, 
                model: $this->model, 
                tupleKey: tuple($token->getUserIdentifier(), $attribute, $subject->getId())
            )
            ->then(fn($response) => $response->getIsAllowed())
            ->recover(fn() => false) // Deny on error
            ->unwrap();
    }
}
```

##### When to use what

- **`unwrap()`** - When you want simple exception-based error handling
- **`success()` / `failure()`** - For side effects like logging without changing the result  
- **`then()`** - To transform success values or chain operations
- **`recover()`** - To provide fallbacks or convert failures to successes

The Result pattern makes error handling explicit and composable. Chain operations confidently knowing failures won't break your pipeline.


### Monitoring and Telemetry

#### OpenTelemetry Observability with the OpenFGA PHP SDK

The OpenFGA PHP SDK includes comprehensive OpenTelemetry support for observability, providing distributed tracing, metrics collection, and telemetry data to help you monitor, debug, and optimize your authorization workflows. Whether you're troubleshooting performance issues or gaining insights into your application's authorization patterns, the SDK's telemetry features give you the visibility you need.

**New to OpenTelemetry?** It's an open-source observability framework that helps you collect, process, and export telemetry data (metrics, logs, and traces) from your applications. Think of it as a way to understand what your application is doing under the hood.

**Already using OpenTelemetry?** The SDK integrates seamlessly with your existing setup - just configure your telemetry provider and start getting insights into your OpenFGA operations automatically.

##### What You'll Get

The SDK automatically instruments and provides telemetry for:

- **HTTP Requests:** All API calls to OpenFGA, including timing, status codes, and errors
- **OpenFGA Operations:** Business-level operations like `check()`, `listObjects()`, `writeTuples()`, etc.
- **Retry Logic:** Failed requests, retry attempts, and backoff delays
- **Circuit Breaker:** State changes and failure rate tracking
- **Authentication:** Token requests, refreshes, and authentication events

##### Prerequisites

- **PHP 8.3+** with the OpenFGA PHP SDK installed
- **OpenTelemetry PHP packages** (optional, but recommended for full functionality):
  ```bash
  composer require open-telemetry/api open-telemetry/sdk
  ```
- **An observability backend** like Jaeger, Zipkin, or a cloud service (optional for getting started)

##### Quick Start

###### 1. Basic Setup (No Backend)

The simplest way to get started is with the built-in telemetry that works without any external dependencies:

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use OpenFGA\Client;
use OpenFGA\Observability\TelemetryFactory;

// Create a telemetry provider
$telemetry = TelemetryFactory::create(
    serviceName: 'my-authorization-service',
    serviceVersion: '1.0.0'
);

// Configure the client with telemetry
$client = new Client(
    url: $_ENV['FGA_API_URL'] ?? 'http://localhost:8080',
    telemetry: $telemetry
);

// Your authorization operations are now automatically instrumented!
$result = $client->check(
    store: 'your-store-id',
    model: 'your-model-id', 
    tupleKey: tuple(user: 'user:anne', relation: 'viewer', object: 'document:readme')
);
?>
```

###### 2. Full OpenTelemetry Setup

For production use with a telemetry backend, install the OpenTelemetry packages and configure them:

```bash
composer require open-telemetry/api open-telemetry/sdk
```

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use OpenFGA\Client;
use OpenFGA\Observability\TelemetryFactory;
use OpenTelemetry\API\Globals;
use OpenTelemetry\API\Trace\Propagation\TraceContextPropagator;
use OpenTelemetry\Contrib\Otlp\SpanExporter;
use OpenTelemetry\SDK\Trace\SpanProcessor\SimpleSpanProcessor;
use OpenTelemetry\SDK\Trace\TracerProvider;

// Configure OpenTelemetry (this is a basic example)
$tracerProvider = new TracerProvider([
    new SimpleSpanProcessor(
        new SpanExporter($_ENV['OTEL_EXPORTER_OTLP_ENDPOINT'] ?? 'http://localhost:4317')
    )
]);

Globals::registerInitializer(function () use ($tracerProvider) {
    return \OpenTelemetry\SDK\Registry::get()->tracerProvider($tracerProvider);
});

// Create telemetry with your service information
$telemetry = TelemetryFactory::create(
    serviceName: 'my-authorization-service',
    serviceVersion: '1.2.3'
);

// Configure client
$client = new Client(
    url: $_ENV['FGA_API_URL'],
    telemetry: $telemetry
);

// Operations are now traced and exported to your backend
$result = $client->listObjects(
    store: 'store_123',
    model: 'model_456',
    user: 'user:anne',
    relation: 'viewer',
    type: 'document'
);
?>
```

##### Telemetry Data Collected

###### HTTP Request Telemetry

Every HTTP request to the OpenFGA API is automatically instrumented:

**Traces (Spans):**
- Span name: `HTTP {METHOD}` (e.g., `HTTP POST`)
- Duration of the entire HTTP request/response cycle
- HTTP method, URL, status code, response size
- Error details if the request fails

**Metrics:**
- `openfga.http.requests.total` - Counter of HTTP requests by method, status code, and success/failure

**Example span attributes:**
```
http.method: POST
http.url: https://api.fga.example/stores/123/check
http.scheme: https
http.host: api.fga.example
http.status_code: 200
http.response.size: 1024
openfga.sdk.name: openfga-php
openfga.sdk.version: 1.0.0
```

###### OpenFGA Operation Telemetry

Business-level operations provide higher-level observability:

**Traces (Spans):**
- Span name: `openfga.{operation}` (e.g., `openfga.check`, `openfga.write_tuples`)
- Duration of the business operation (may include multiple HTTP calls)
- Store ID, model ID, and operation-specific metadata

**Metrics:**
- `openfga.operations.total` - Counter of operations by type, store, success/failure
- `openfga.operations.duration` - Histogram of operation durations

**Example operation span:**
```
openfga.operation: check
openfga.store_id: store_01H1234567890ABCDEF
openfga.model_id: model_01H1234567890ABCDEF
openfga.sdk.name: openfga-php
openfga.sdk.version: 1.0.0
```

###### Retry and Reliability Telemetry

The SDK automatically tracks retry attempts and circuit breaker behavior:

**Retry Metrics:**
- `openfga.retries.total` - Counter of retry attempts by endpoint and outcome
- `openfga.retries.delay` - Histogram of retry delays in milliseconds

**Circuit Breaker Metrics:**
- `openfga.circuit_breaker.state_changes.total` - Counter of state changes (open/closed)

**Authentication Telemetry:**
- `openfga.auth.events.total` - Counter of authentication events
- `openfga.auth.duration` - Histogram of authentication operation durations

##### Configuration Options

###### Service Identification

Configure your service information for better observability:

```php
$telemetry = TelemetryFactory::create(
    serviceName: 'user-management-api',     // Your service name
    serviceVersion: '2.1.0'                 // Your service version
);
```

###### Custom Telemetry Providers

You can provide your own configured OpenTelemetry tracer and meter:

```php
use OpenFGA\Observability\TelemetryFactory;
use OpenTelemetry\API\Globals;

// Get your configured tracer and meter
$tracer = Globals::tracerProvider()->getTracer('my-service', '1.0.0');
$meter = Globals::meterProvider()->getMeter('my-service', '1.0.0');

// Create telemetry with custom providers
$telemetry = TelemetryFactory::createWithCustomProviders($tracer, $meter);

$client = new Client(
    url: $_ENV['FGA_API_URL'],
    telemetry: $telemetry
);
```

###### No-Op Mode

For testing or when you want to disable telemetry:

```php
use OpenFGA\Observability\TelemetryFactory;

// Explicitly disable telemetry
$telemetry = TelemetryFactory::createNoOp();

$client = new Client(
    url: $_ENV['FGA_API_URL'],
    telemetry: $telemetry
);
```

##### Common Integration Patterns

###### Jaeger (Local Development)

For local development with Jaeger:

```bash
#### Start Jaeger with Docker
docker run -d --name jaeger \
  -p 16686:16686 \
  -p 14250:14250 \
  jaegertracing/all-in-one:latest
```

```php
<?php
use OpenTelemetry\Contrib\Jaeger\Exporter as JaegerExporter;
use OpenTelemetry\SDK\Trace\SpanProcessor\SimpleSpanProcessor;
use OpenTelemetry\SDK\Trace\TracerProvider;

$tracerProvider = new TracerProvider([
    new SimpleSpanProcessor(
        new JaegerExporter(
            'my-service',
            'http://localhost:14268/api/traces'
        )
    )
]);

Globals::registerInitializer(function () use ($tracerProvider) {
    return \OpenTelemetry\SDK\Registry::get()->tracerProvider($tracerProvider);
});

$telemetry = TelemetryFactory::create('my-service', '1.0.0');
?>
```

###### Cloud Providers

For cloud-based observability services:

```php
<?php
// AWS X-Ray, Google Cloud Trace, Azure Monitor, etc.
use OpenTelemetry\Contrib\Otlp\SpanExporter;

$exporter = new SpanExporter($_ENV['OTEL_EXPORTER_OTLP_ENDPOINT']);
// Configure with your cloud provider's specific settings
?>
```

###### Existing OpenTelemetry Setup

If you already have OpenTelemetry configured in your application:

```php
<?php
// The SDK will automatically use your existing global configuration
$telemetry = TelemetryFactory::create('my-authorization-service');

$client = new Client(
    url: $_ENV['FGA_API_URL'],
    telemetry: $telemetry
);

// Traces will be included in your existing observability setup
?>
```

##### Example: Complete Authorization Workflow with Tracing

Here's a complete example showing how telemetry works throughout an authorization workflow:

```php
<?php

require_once __DIR__ . '/vendor/autoload.php';

use OpenFGA\Client;
use OpenFGA\Observability\TelemetryFactory;
use function OpenFGA\{tuple, tuples};

// Configure telemetry (assumes OpenTelemetry is set up)
$telemetry = TelemetryFactory::create(
    serviceName: 'document-service',
    serviceVersion: '1.0.0'
);

$client = new Client(
    url: $_ENV['FGA_API_URL'],
    telemetry: $telemetry
);

try {
    // Each operation creates its own span with timing and metadata
    
    // 1. Create store - traced as "openfga.create_store"
    $store = $client->createStore(name: 'document-service-store')
        ->unwrap();
    
    // 2. Create model - traced as "openfga.create_authorization_model"  
    $model = $client->createAuthorizationModel(
        store: $store->getId(),
        typeDefinitions: $authModel->getTypeDefinitions()
    )->unwrap();
    
    // 3. Write relationships - traced as "openfga.write_tuples"
    $client->writeTuples(
        store: $store->getId(),
        model: $model->getId(),
        writes: tuples(
            tuple(user: 'user:anne', relation: 'viewer', object: 'document:readme'),
            tuple(user: 'user:bob', relation: 'editor', object: 'document:readme')
        )
    )->unwrap();
    
    // 4. Check authorization - traced as "openfga.check"
    $allowed = $client->check(
        store: $store->getId(),
        model: $model->getId(),
        tupleKey: tuple(user: 'user:anne', relation: 'viewer', object: 'document:readme')
    )->unwrap();
    
    // 5. List accessible objects - traced as "openfga.list_objects"
    $documents = $client->listObjects(
        store: $store->getId(),
        model: $model->getId(),
        user: 'user:anne',
        relation: 'viewer',
        type: 'document'
    )->unwrap();
    
    echo "Authorization check complete. Anne can view document: " . 
         ($allowed->getAllowed() ? 'Yes' : 'No') . "\n";
    echo "Documents Anne can view: " . count($documents->getObjects()) . "\n";
    
} catch (Throwable $e) {
    // Errors are automatically recorded in spans
    echo "Authorization failed: " . $e->getMessage() . "\n";
}
?>
```

##### Viewing Your Telemetry Data

###### In Jaeger UI

1. Open http://localhost:16686 in your browser
2. Select your service name from the dropdown
3. Click "Find Traces" to see recent authorization operations
4. Click on a trace to see the detailed span timeline

###### Key Things to Look For

**Performance Analysis:**
- Which operations take the longest?
- Are there patterns in slow requests?
- How do retry attempts affect overall timing?

**Error Investigation:**
- What HTTP status codes are you getting?
- Which OpenFGA operations are failing?
- Are authentication issues causing problems?

**Usage Patterns:**
- Which stores and models are accessed most frequently?
- What types of authorization checks are most common?
- How often do retries occur?

##### Troubleshooting

###### No Telemetry Data

1. **Check if OpenTelemetry is properly installed:**
   ```bash
   composer show | grep open-telemetry
   ```

2. **Verify your exporter configuration:**
   ```php
   // Add debug output
   $telemetry = TelemetryFactory::create('test-service');
   if ($telemetry instanceof \OpenFGA\Observability\OpenTelemetryProvider) {
       echo "Using OpenTelemetry provider\n";
   } else {
       echo "Using no-op provider\n";
   }
   ```

3. **Check your backend connectivity:**
   - Ensure your OTLP endpoint is reachable
   - Verify authentication if required
   - Check firewall and network settings

###### Performance Impact

The telemetry overhead is minimal in production:

- **No-op mode:** Virtually zero overhead when telemetry is disabled
- **OpenTelemetry mode:** Low overhead (~1-2% typically) with async exporters
- **Graceful degradation:** Continues working even if telemetry backend is unavailable

###### Environment Variables

Common OpenTelemetry environment variables that work with the SDK:

```bash
#### Service identification
export OTEL_SERVICE_NAME="my-authorization-service"
export OTEL_SERVICE_VERSION="1.0.0"

#### Exporter configuration  
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"
export OTEL_EXPORTER_OTLP_HEADERS="api-key=your-api-key"

#### Sampling (to reduce overhead in high-traffic scenarios)
export OTEL_TRACES_SAMPLER="traceidratio"
export OTEL_TRACES_SAMPLER_ARG="0.1"  # Sample 10% of traces
```

##### Advanced Usage

###### Custom Attributes

Add custom context to your authorization operations:

```php
// The SDK automatically includes relevant attributes, but you can add more context
// when configuring your service or through OpenTelemetry's context propagation

use OpenTelemetry\API\Trace\Span;

// Add custom attributes to the current span
$span = Span::getCurrent();
$span->setAttribute('user.department', 'engineering');
$span->setAttribute('request.source', 'mobile-app');

// Now perform your authorization check
$result = $client->check(/* ... */);
```

###### Correlation with Application Traces

The SDK integrates with your application's existing traces:

```php
// If you have an existing span (e.g., from a web request)
$parentSpan = $yourFramework->getCurrentSpan();

// OpenFGA operations will automatically become child spans
$result = $client->check(/* ... */); // This becomes a child of $parentSpan
```

###### Metrics-Only Mode

If you only want metrics without distributed tracing:

```php
// Configure OpenTelemetry with metrics only
use OpenTelemetry\SDK\Metrics\MeterProvider;

$meterProvider = new MeterProvider(/* your exporters */);
// Don't configure a tracer provider

$telemetry = TelemetryFactory::create('my-service');
```

##### Next Steps

**Getting Started:**
- Try the basic setup with your existing OpenFGA instance
- Add Jaeger for local development to see traces immediately
- Review the [Introduction.md](Introduction.md) guide for basic OpenFGA usage

**Production Setup:**
- Configure proper sampling rates for high-traffic applications
- Set up dashboards in your observability platform
- Implement alerting on key metrics like error rates and latency

**Integration:**
- Explore the [Authentication.md](Authentication.md) guide for secure telemetry
- Read about [Results.md](Results.md) for error handling patterns that work well with observability
- Check [Queries.md](Queries.md) for the operations you'll be monitoring

For more details on the OpenTelemetry ecosystem, visit the [official OpenTelemetry documentation](https://opentelemetry.io/docs/).

### Framework Integration

#### Service Provider Integration

The OpenFGA PHP SDK supports automatic dependency injection container registration through the [tbachert/spi](https://packagist.org/packages/tbachert/spi) service provider interface pattern.

##### What is this?

If your framework or application uses a dependency injection container that supports automatic service discovery, the OpenFGA SDK can automatically register its services without manual configuration.

This is particularly useful for:
- Laravel applications with service auto-discovery
- Symfony applications with auto-wiring
- Custom frameworks with SPI support
- Any application using tbachert/spi

##### Installation

The SPI integration is completely optional. Install the service provider package if you want automatic registration:

```bash
composer require tbachert/spi
```

That's it! The OpenFGA services will be automatically available in your container.

##### What gets registered?

The service provider automatically registers these configuration-free interfaces:

- **`OpenFGA\Observability\TelemetryInterface`** - No-op telemetry provider (can be overridden)
- **`OpenFGA\TransformerInterface`** - DSL to model transformation
- **`OpenFGA\Schema\SchemaValidatorInterface`** - JSON schema validation for models

**Note:** `ClientInterface` and `RequestManagerInterface` are NOT automatically registered because they require configuration (URL, authentication, etc.). You'll need to register these manually in your application.

##### Usage examples

###### Laravel

First, register the OpenFGA client in your service provider:

```php
// In your AppServiceProvider
public function register()
{
    // Register the client (requires manual configuration)
    $this->app->singleton(ClientInterface::class, function () {
        return new Client(
            url: config('openfga.api_url'),
            authentication: new ClientCredentialAuthentication(
                clientId: config('openfga.client_id'),
                clientSecret: config('openfga.client_secret')
            )
        );
    });
}
```

Then use it in controllers or services:

```php
use function OpenFGA\tuple;

// In any Laravel service, controller, or job
class DocumentController extends Controller
{
    public function __construct(
        private readonly ClientInterface $openfga
    ) {}

    public function show(Request $request, string $documentId)
    {
        $canView = $this->openfga->check(
            store: config('openfga.store_id'),
            model: config('openfga.model_id'),
            tupleKey: tuple(
                user: "user:{$request->user()->id}",
                relation: 'viewer',
                object: "document:{$documentId}"
            )
        )->unwrap()->getAllowed();

        if (!$canView) {
            abort(403, 'Access denied');
        }

        return view('documents.show', compact('documentId'));
    }
}
```

###### Symfony

First, configure the client in your services configuration:

```yaml
#### config/services.yaml
services:
  # Configure the OpenFGA client
  OpenFGA\ClientInterface:
    class: OpenFGA\Client
    arguments:
      url: '%env(OPENFGA_API_URL)%'
      authentication: '@openfga.auth'
      
  # Configure authentication
  openfga.auth:
    class: OpenFGA\Authentication\ClientCredentialAuthentication
    arguments:
      clientId: '%env(OPENFGA_CLIENT_ID)%'
      clientSecret: '%env(OPENFGA_CLIENT_SECRET)%'
```

Then use it in services or controllers:

```php
use function OpenFGA\tuple;

// In any Symfony service or controller
class DocumentService
{
    public function __construct(
        private readonly ClientInterface $openfga
    ) {}

    public function canUserEdit(string $userId, string $documentId): bool
    {
        return $this->openfga->check(
            store: $_ENV['OPENFGA_STORE_ID'],
            model: $_ENV['OPENFGA_MODEL_ID'],
            tupleKey: tuple(
                user: "user:{$userId}",
                relation: 'editor',
                object: "document:{$documentId}"
            )
        )->unwrap()->getAllowed();
    }
}
```

###### Custom dependency injection

```php
// Basic services are automatically registered when tbachert/spi is installed
$container = new YourContainer();

// Register the client manually (requires configuration)
$container->singleton(ClientInterface::class, function() {
    return new Client(
        url: 'https://api.fga.example',
        authentication: new ClientCredentialAuthentication(
            clientId: 'your-client-id',
            clientSecret: 'your-client-secret'
        )
    );
});

// Use the configured client
$client = $container->get(ClientInterface::class);
$canEdit = $client->check(/* ... */)->unwrap()->getAllowed();
```

##### Customizing services

You can override any of the registered services in your application:

###### Laravel service provider

```php
// In your AppServiceProvider
public function register()
{
    // Override telemetry with OpenTelemetry implementation
    $this->app->singleton(TelemetryInterface::class, function () {
        return new OpenTelemetryProvider(/* your config */);
    });
    
    // Register the client (always required)
    $this->app->singleton(ClientInterface::class, function () {
        return new Client(
            url: config('openfga.api_url'),
            authentication: new ClientCredentialAuthentication(
                clientId: config('openfga.client_id'),
                clientSecret: config('openfga.client_secret')
            )
        );
    });
}
```

###### Symfony services configuration

```yaml
#### config/services.yaml
services:
  # Override telemetry with OpenTelemetry
  OpenFGA\Observability\TelemetryInterface:
    class: OpenFGA\Observability\OpenTelemetryProvider
    arguments:
      - '@open_telemetry.meter_provider'
      - '@open_telemetry.tracer_provider'

  # Register client configuration (always required)
  OpenFGA\ClientInterface:
    class: OpenFGA\Client
    arguments:
      url: '%env(OPENFGA_API_URL)%'
      authentication: '@openfga.auth'
```

##### Manual registration

If you prefer manual control or don't want to use tbachert/spi, you can register services manually:

```php
use OpenFGA\Client;
use OpenFGA\ClientInterface;
use OpenFGA\Integration\ServiceProvider;

$container = new YourContainer();

// Manual registration using the service provider
$serviceProvider = new ServiceProvider();
$serviceProvider->register($container);

// Or register services individually
$container->singleton(ClientInterface::class, function () {
    return new Client(url: 'https://api.fga.example');
});
```

##### Troubleshooting

**Services not being registered?**
- Ensure `tbachert/spi` is installed: `composer require tbachert/spi`
- Check that the plugin is enabled: `composer config allow-plugins.tbachert/spi true`
- Verify your container supports automatic service discovery

**Need different configuration?**
- Override services in your application's service provider
- Use manual registration instead of automatic discovery
- Configure the client directly without dependency injection

**Framework-specific issues?**
- Laravel: Services should be available immediately after installation
- Symfony: May require clearing cache: `bin/console cache:clear`
- Custom frameworks: Ensure your container supports one of the common DI methods

##### Next steps

With automatic service registration working, you can focus on:

- **[Setting up authentication](Authentication.md)** for production environments
- **[Creating authorization models](Models.md)** to define your permission rules  
- **[Writing queries](Queries.md)** to check permissions in your application
- **[Adding observability](Observability.md)** with OpenTelemetry integration

## API Reference Documentation

Complete API documentation is available in the `/docs/API/` directory. Here's the organized structure:

### Core Classes

- [Main OpenFGA client with all operations](docs/API/Client.md)
- [Client interface definition](docs/API/ClientInterface.md)
- [DSL to authorization model transformer](docs/API/Transformer.md)
- [Transformer interface](docs/API/TransformerInterface.md)
- [Internationalization messages](docs/API/Messages.md)

### Authentication

- [Base authentication interface](docs/API/Authentication/Authentication/AuthenticationInterface.md)
- [Pre-shared key authentication](docs/API/Authentication/Authentication/TokenAuthentication.md)
- [OAuth 2.0 client credentials](docs/API/Authentication/Authentication/ClientCredentialAuthentication.md)
- [OAuth access token management](docs/API/Authentication/Authentication/AccessToken.md)
- [Access token interface](docs/API/Authentication/Authentication/AccessTokenInterface.md)

### Models and Data Structures

- [Store model for data isolation](docs/API/Models/Models/Store.md)
- [Store interface](docs/API/Models/Models/StoreInterface.md)
- [Authorization model with type definitions](docs/API/Models/Models/AuthorizationModel.md)
- [Authorization model interface](docs/API/Models/Models/AuthorizationModelInterface.md)
- [Relationship tuple key (user, relation, object)](docs/API/Models/Models/TupleKey.md)
- [Tuple key interface](docs/API/Models/Models/TupleKeyInterface.md)
- [Complete relationship tuple with metadata](docs/API/Models/Models/Tuple.md)
- [Tuple interface](docs/API/Models/Models/TupleInterface.md)
- [Type definition with relations](docs/API/Models/Models/TypeDefinition.md)
- [Type definition interface](docs/API/Models/Models/TypeDefinitionInterface.md)
- [Conditional authorization logic](docs/API/Models/Models/Condition.md)
- [Condition interface](docs/API/Models/Models/ConditionInterface.md)

### Collections

- [Collection of tuple keys](docs/API/Models/Collections/Models/Collections/TupleKeys.md)
- [Tuple keys collection interface](docs/API/Models/Collections/Models/Collections/TupleKeysInterface.md)
- [Collection of tuples](docs/API/Models/Collections/Models/Collections/Tuples.md)
- [Tuples collection interface](docs/API/Models/Collections/Models/Collections/TuplesInterface.md)
- [Collection of type definitions](docs/API/Models/Collections/Models/Collections/TypeDefinitions.md)
- [Type definitions collection interface](docs/API/Models/Collections/Models/Collections/TypeDefinitionsInterface.md)
- [Batch check items collection](docs/API/Models/Collections/Models/Collections/BatchCheckItems.md)
- [Batch check items interface](docs/API/Models/Collections/Models/Collections/BatchCheckItemsInterface.md)
- [Collection of stores](docs/API/Models/Collections/Models/Collections/Stores.md)
- [Stores collection interface](docs/API/Models/Collections/Models/Collections/StoresInterface.md)

### Enumerations

- [Consistency levels for queries](docs/API/Models/Enums/Models/Enums/Consistency.md)
- [Authorization model schema versions](docs/API/Models/Enums/Models/Enums/SchemaVersion.md)
- [Tuple write operations (write/delete)](docs/API/Models/Enums/Models/Enums/TupleOperation.md)
- [Built-in type names](docs/API/Models/Enums/Models/Enums/TypeName.md)

### Requests and Responses

- [Authorization check request](docs/API/Requests/CheckRequest.md)
- [Check request interface](docs/API/Requests/CheckRequestInterface.md)
- [Batch authorization check request](docs/API/Requests/BatchCheckRequest.md)
- [Batch check request interface](docs/API/Requests/BatchCheckRequestInterface.md)
- [Write/delete tuples request](docs/API/Requests/WriteTuplesRequest.md)
- [Write tuples request interface](docs/API/Requests/WriteTuplesRequestInterface.md)
- [Read tuples request](docs/API/Requests/ReadTuplesRequest.md)
- [Read tuples request interface](docs/API/Requests/ReadTuplesRequestInterface.md)
- [Authorization check response](docs/API/Responses/CheckResponse.md)
- [Check response interface](docs/API/Responses/CheckResponseInterface.md)
- [Batch check response](docs/API/Responses/BatchCheckResponse.md)
- [Batch check response interface](docs/API/Responses/BatchCheckResponseInterface.md)

### Results and Error Handling

- [Success result wrapper](docs/API/Results/Results/Success.md)
- [Success interface](docs/API/Results/Results/SuccessInterface.md)
- [Failure result wrapper](docs/API/Results/Results/Failure.md)
- [Failure interface](docs/API/Results/Results/FailureInterface.md)
- [Base result interface](docs/API/Results/Results/ResultInterface.md)

### Exceptions

- [Base client exception](docs/API/Exceptions/Exceptions/ClientException.md)
- [Client throwable interface](docs/API/Exceptions/Exceptions/ClientThrowable.md)
- [Authentication errors](docs/API/Exceptions/Exceptions/AuthenticationException.md)
- [Configuration errors](docs/API/Exceptions/Exceptions/ConfigurationException.md)
- [Network and HTTP errors](docs/API/Exceptions/Exceptions/NetworkException.md)
- [Serialization errors](docs/API/Exceptions/Exceptions/SerializationException.md)

### Network and Infrastructure

- [HTTP request management](docs/API/Network/Network/RequestManager.md)
- [Request manager interface](docs/API/Network/Network/RequestManagerInterface.md)
- [Retry logic with exponential backoff](docs/API/Network/Network/RetryHandler.md)
- [Retry handler interface](docs/API/Network/Network/RetryHandlerInterface.md)
- [Circuit breaker for fault tolerance](docs/API/Network/Network/CircuitBreaker.md)
- [Circuit breaker interface](docs/API/Network/Network/CircuitBreakerInterface.md)
- [Request context and metadata](docs/API/Network/Network/RequestContext.md)
- [Request context interface](docs/API/Network/Network/RequestContextInterface.md)

### Observability and Monitoring

- [Telemetry provider interface](docs/API/Observability/Observability/TelemetryInterface.md)
- [OpenTelemetry integration](docs/API/Observability/Observability/OpenTelemetryProvider.md)
- [No-op telemetry provider](docs/API/Observability/Observability/NoOpTelemetryProvider.md)
- [Telemetry provider factory](docs/API/Observability/Observability/TelemetryFactory.md)

### Schema Validation

- [JSON schema definitions](docs/API/Schema/Schema/Schema.md)
- [Schema interface](docs/API/Schema/Schema/SchemaInterface.md)
- [Schema validation logic](docs/API/Schema/Schema/SchemaValidator.md)
- [Schema validator interface](docs/API/Schema/Schema/SchemaValidatorInterface.md)
- [Schema builder for dynamic schemas](docs/API/Schema/Schema/SchemaBuilder.md)
- [Schema builder interface](docs/API/Schema/Schema/SchemaBuilderInterface.md)

### Translation and Internationalization

- [Message translation service](docs/API/Translation/Translation/Translator.md)
- [Translator interface](docs/API/Translation/Translation/TranslatorInterface.md)
- [YAML parser for translation files](docs/API/Translation/Translation/YamlParser.md)

### Framework Integration

- [Laravel service provider](docs/API/Integration/Integration/ServiceProvider.md)

## Quick Reference for AI Assistants

### Common Usage Patterns

#### Basic Authorization Check
```php
use OpenFGA\Client;
use OpenFGA\Models\TupleKey;

$client = new Client(url: 'https://api.fga.example');

$result = $client->check(
    store: 'store_123',
    model: 'model_456',
    tupleKey: new TupleKey('user:alice', 'viewer', 'document:readme')
);

if ($result->success()) {
    $allowed = $result->value()->getAllowed();
}
```

#### Batch Authorization Checks
```php
use OpenFGA\Models\Collections\BatchCheckItems;
use OpenFGA\Models\BatchCheckItem;

$checks = new BatchCheckItems([
    new BatchCheckItem(
        tupleKey: new TupleKey('user:alice', 'viewer', 'document:budget'),
        correlationId: 'check-1'
    ),
    new BatchCheckItem(
        tupleKey: new TupleKey('user:bob', 'editor', 'document:budget'),
        correlationId: 'check-2'
    ),
]);

$result = $client->batchCheck(
    store: 'store_123',
    model: 'model_456',
    checks: $checks
);
```

#### DSL Authorization Model
```php
$dsl = '
    model
      schema 1.1

    type user

    type document
      relations
        define owner: [user]
        define editor: [user] or owner
        define viewer: [user] or editor
';

$model = $client->dsl($dsl)->unwrap();
```

#### Writing Relationship Tuples
```php
use OpenFGA\Models\Collections\TupleKeys;

$writes = new TupleKeys([
    new TupleKey('user:alice', 'owner', 'document:budget'),
    new TupleKey('user:bob', 'viewer', 'document:budget'),
]);

$result = $client->writeTuples(
    store: 'store_123',
    model: 'model_456',
    writes: $writes
);
```

#### List Objects a User Can Access
```php
$result = $client->listObjects(
    store: 'store_123',
    model: 'model_456',
    type: 'document',
    relation: 'viewer',
    user: 'user:alice'
);

if ($result->success()) {
    $documents = $result->value()->getObjects();
}
```

### Result Pattern Usage

The SDK uses the Result pattern instead of exceptions for expected failures:

```php
// Handle results with method chaining
$documents = $client->listObjects(...)
    ->success(fn($response) => echo "Found objects!")
    ->failure(fn($error) => echo "Error: " . $error->getMessage())
    ->unwrap(); // Gets value or throws exception

// Handle results with conditionals
$result = $client->check(...);
if ($result->success()) {
    $allowed = $result->value()->getAllowed();
} else {
    $error = $result->error();
    // Handle error
}
```

### Authentication Configuration

#### Pre-shared Key
```php
use OpenFGA\Authentication\TokenAuthentication;

$auth = new TokenAuthentication('your-api-key');
$client = new Client(
    url: 'https://api.fga.example',
    authentication: $auth
);
```

#### OAuth 2.0 Client Credentials
```php
use OpenFGA\Authentication\ClientCredentialAuthentication;

$auth = new ClientCredentialAuthentication(
    clientId: 'your-client-id',
    clientSecret: 'your-client-secret',
    tokenUrl: 'https://auth.fga.example/oauth/token'
);
$client = new Client(
    url: 'https://api.fga.example',
    authentication: $auth
);
```

### Common Commands

- **Install:** `composer require evansims/openfga-php`
- **Run Tests:** `composer test`
- **Generate API Docs:** `composer docs:api`
- **Generate LLMs.txt:** `composer docs:llms`
- **Lint Code:** `composer lint`

### Framework Integration

#### Laravel Service Provider
```php
// In config/app.php
'providers' => [
    OpenFGA\Integration\ServiceProvider::class,
],
```

The service provider registers the OpenFGA client in the container and provides configuration through Laravel's config system.

### Key Architecture Concepts

1. **Result Pattern:** All operations return Success/Failure objects instead of throwing exceptions
2. **Interface-First Design:** Every class implements an interface for testing and flexibility
3. **Type Safety:** Full PHP 8.3+ type hints throughout
4. **PSR Compliance:** Uses PSR-7/17/18 for HTTP handling
5. **Immutable Models:** All data models are immutable value objects
6. **Collection Types:** Type-safe collections for working with multiple objects
7. **Schema Validation:** Built-in JSON schema validation for all API interactions